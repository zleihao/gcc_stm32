ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 1


   1              		.cpu cortex-m3
   2              		.arch armv7-m
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.file	"ipc.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.rt_list_init,"ax",%progbits
  18              		.align	1
  19              		.syntax unified
  20              		.thumb
  21              		.thumb_func
  23              	rt_list_init:
  24              	.LFB0:
  25              		.file 1 "./rt_thread/include/rtservice.h"
   1:./rt_thread/include/rtservice.h **** /*
   2:./rt_thread/include/rtservice.h ****  * Copyright (c) 2006-2021, RT-Thread Development Team
   3:./rt_thread/include/rtservice.h ****  *
   4:./rt_thread/include/rtservice.h ****  * SPDX-License-Identifier: Apache-2.0
   5:./rt_thread/include/rtservice.h ****  *
   6:./rt_thread/include/rtservice.h ****  * Change Logs:
   7:./rt_thread/include/rtservice.h ****  * Date           Author       Notes
   8:./rt_thread/include/rtservice.h ****  * 2006-03-16     Bernard      the first version
   9:./rt_thread/include/rtservice.h ****  * 2006-09-07     Bernard      move the kservice APIs to rtthread.h
  10:./rt_thread/include/rtservice.h ****  * 2007-06-27     Bernard      fix the rt_list_remove bug
  11:./rt_thread/include/rtservice.h ****  * 2012-03-22     Bernard      rename kservice.h to rtservice.h
  12:./rt_thread/include/rtservice.h ****  * 2017-11-15     JasonJia     Modify rt_slist_foreach to rt_slist_for_each_entry.
  13:./rt_thread/include/rtservice.h ****  *                             Make code cleanup.
  14:./rt_thread/include/rtservice.h ****  */
  15:./rt_thread/include/rtservice.h **** 
  16:./rt_thread/include/rtservice.h **** #ifndef __RT_SERVICE_H__
  17:./rt_thread/include/rtservice.h **** #define __RT_SERVICE_H__
  18:./rt_thread/include/rtservice.h **** 
  19:./rt_thread/include/rtservice.h **** #ifdef __cplusplus
  20:./rt_thread/include/rtservice.h **** extern "C" {
  21:./rt_thread/include/rtservice.h **** #endif
  22:./rt_thread/include/rtservice.h **** 
  23:./rt_thread/include/rtservice.h **** /**
  24:./rt_thread/include/rtservice.h ****  * @addtogroup KernelService
  25:./rt_thread/include/rtservice.h ****  */
  26:./rt_thread/include/rtservice.h **** 
  27:./rt_thread/include/rtservice.h **** /**@{*/
  28:./rt_thread/include/rtservice.h **** 
  29:./rt_thread/include/rtservice.h **** /**
  30:./rt_thread/include/rtservice.h ****  * rt_container_of - return the member address of ptr, if the type of ptr is the
  31:./rt_thread/include/rtservice.h ****  * struct type.
  32:./rt_thread/include/rtservice.h ****  */
  33:./rt_thread/include/rtservice.h **** #define rt_container_of(ptr, type, member) \
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 2


  34:./rt_thread/include/rtservice.h ****     ((type *)((char *)(ptr) - (unsigned long)(&((type *)0)->member)))
  35:./rt_thread/include/rtservice.h **** 
  36:./rt_thread/include/rtservice.h **** 
  37:./rt_thread/include/rtservice.h **** /**
  38:./rt_thread/include/rtservice.h ****  * @brief initialize a list object
  39:./rt_thread/include/rtservice.h ****  */
  40:./rt_thread/include/rtservice.h **** #define RT_LIST_OBJECT_INIT(object) { &(object), &(object) }
  41:./rt_thread/include/rtservice.h **** 
  42:./rt_thread/include/rtservice.h **** /**
  43:./rt_thread/include/rtservice.h ****  * @brief initialize a list
  44:./rt_thread/include/rtservice.h ****  *
  45:./rt_thread/include/rtservice.h ****  * @param l list to be initialized
  46:./rt_thread/include/rtservice.h ****  */
  47:./rt_thread/include/rtservice.h **** rt_inline void rt_list_init(rt_list_t *l)
  48:./rt_thread/include/rtservice.h **** {
  26              		.loc 1 48 1
  27              		.cfi_startproc
  28              		@ args = 0, pretend = 0, frame = 8
  29              		@ frame_needed = 1, uses_anonymous_args = 0
  30              		@ link register save eliminated.
  31 0000 80B4     		push	{r7}
  32              	.LCFI0:
  33              		.cfi_def_cfa_offset 4
  34              		.cfi_offset 7, -4
  35 0002 83B0     		sub	sp, sp, #12
  36              	.LCFI1:
  37              		.cfi_def_cfa_offset 16
  38 0004 00AF     		add	r7, sp, #0
  39              	.LCFI2:
  40              		.cfi_def_cfa_register 7
  41 0006 7860     		str	r0, [r7, #4]
  49:./rt_thread/include/rtservice.h ****     l->next = l->prev = l;
  42              		.loc 1 49 23
  43 0008 7B68     		ldr	r3, [r7, #4]
  44 000a 7A68     		ldr	r2, [r7, #4]
  45 000c 5A60     		str	r2, [r3, #4]
  46              		.loc 1 49 16
  47 000e 7B68     		ldr	r3, [r7, #4]
  48 0010 5A68     		ldr	r2, [r3, #4]
  49              		.loc 1 49 13
  50 0012 7B68     		ldr	r3, [r7, #4]
  51 0014 1A60     		str	r2, [r3]
  50:./rt_thread/include/rtservice.h **** }
  52              		.loc 1 50 1
  53 0016 00BF     		nop
  54 0018 0C37     		adds	r7, r7, #12
  55              	.LCFI3:
  56              		.cfi_def_cfa_offset 4
  57 001a BD46     		mov	sp, r7
  58              	.LCFI4:
  59              		.cfi_def_cfa_register 13
  60              		@ sp needed
  61 001c 80BC     		pop	{r7}
  62              	.LCFI5:
  63              		.cfi_restore 7
  64              		.cfi_def_cfa_offset 0
  65 001e 7047     		bx	lr
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 3


  66              		.cfi_endproc
  67              	.LFE0:
  69              		.section	.text.rt_list_insert_before,"ax",%progbits
  70              		.align	1
  71              		.syntax unified
  72              		.thumb
  73              		.thumb_func
  75              	rt_list_insert_before:
  76              	.LFB2:
  51:./rt_thread/include/rtservice.h **** 
  52:./rt_thread/include/rtservice.h **** /**
  53:./rt_thread/include/rtservice.h ****  * @brief insert a node after a list
  54:./rt_thread/include/rtservice.h ****  *
  55:./rt_thread/include/rtservice.h ****  * @param l list to insert it
  56:./rt_thread/include/rtservice.h ****  * @param n new node to be inserted
  57:./rt_thread/include/rtservice.h ****  */
  58:./rt_thread/include/rtservice.h **** rt_inline void rt_list_insert_after(rt_list_t *l, rt_list_t *n)
  59:./rt_thread/include/rtservice.h **** {
  60:./rt_thread/include/rtservice.h ****     l->next->prev = n;
  61:./rt_thread/include/rtservice.h ****     n->next = l->next;
  62:./rt_thread/include/rtservice.h **** 
  63:./rt_thread/include/rtservice.h ****     l->next = n;
  64:./rt_thread/include/rtservice.h ****     n->prev = l;
  65:./rt_thread/include/rtservice.h **** }
  66:./rt_thread/include/rtservice.h **** 
  67:./rt_thread/include/rtservice.h **** /**
  68:./rt_thread/include/rtservice.h ****  * @brief insert a node before a list
  69:./rt_thread/include/rtservice.h ****  *
  70:./rt_thread/include/rtservice.h ****  * @param n new node to be inserted
  71:./rt_thread/include/rtservice.h ****  * @param l list to insert it
  72:./rt_thread/include/rtservice.h ****  */
  73:./rt_thread/include/rtservice.h **** rt_inline void rt_list_insert_before(rt_list_t *l, rt_list_t *n)
  74:./rt_thread/include/rtservice.h **** {
  77              		.loc 1 74 1
  78              		.cfi_startproc
  79              		@ args = 0, pretend = 0, frame = 8
  80              		@ frame_needed = 1, uses_anonymous_args = 0
  81              		@ link register save eliminated.
  82 0000 80B4     		push	{r7}
  83              	.LCFI6:
  84              		.cfi_def_cfa_offset 4
  85              		.cfi_offset 7, -4
  86 0002 83B0     		sub	sp, sp, #12
  87              	.LCFI7:
  88              		.cfi_def_cfa_offset 16
  89 0004 00AF     		add	r7, sp, #0
  90              	.LCFI8:
  91              		.cfi_def_cfa_register 7
  92 0006 7860     		str	r0, [r7, #4]
  93 0008 3960     		str	r1, [r7]
  75:./rt_thread/include/rtservice.h ****     l->prev->next = n;
  94              		.loc 1 75 6
  95 000a 7B68     		ldr	r3, [r7, #4]
  96 000c 5B68     		ldr	r3, [r3, #4]
  97              		.loc 1 75 19
  98 000e 3A68     		ldr	r2, [r7]
  99 0010 1A60     		str	r2, [r3]
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 4


  76:./rt_thread/include/rtservice.h ****     n->prev = l->prev;
 100              		.loc 1 76 16
 101 0012 7B68     		ldr	r3, [r7, #4]
 102 0014 5A68     		ldr	r2, [r3, #4]
 103              		.loc 1 76 13
 104 0016 3B68     		ldr	r3, [r7]
 105 0018 5A60     		str	r2, [r3, #4]
  77:./rt_thread/include/rtservice.h **** 
  78:./rt_thread/include/rtservice.h ****     l->prev = n;
 106              		.loc 1 78 13
 107 001a 7B68     		ldr	r3, [r7, #4]
 108 001c 3A68     		ldr	r2, [r7]
 109 001e 5A60     		str	r2, [r3, #4]
  79:./rt_thread/include/rtservice.h ****     n->next = l;
 110              		.loc 1 79 13
 111 0020 3B68     		ldr	r3, [r7]
 112 0022 7A68     		ldr	r2, [r7, #4]
 113 0024 1A60     		str	r2, [r3]
  80:./rt_thread/include/rtservice.h **** }
 114              		.loc 1 80 1
 115 0026 00BF     		nop
 116 0028 0C37     		adds	r7, r7, #12
 117              	.LCFI9:
 118              		.cfi_def_cfa_offset 4
 119 002a BD46     		mov	sp, r7
 120              	.LCFI10:
 121              		.cfi_def_cfa_register 13
 122              		@ sp needed
 123 002c 80BC     		pop	{r7}
 124              	.LCFI11:
 125              		.cfi_restore 7
 126              		.cfi_def_cfa_offset 0
 127 002e 7047     		bx	lr
 128              		.cfi_endproc
 129              	.LFE2:
 131              		.section	.text.rt_list_isempty,"ax",%progbits
 132              		.align	1
 133              		.syntax unified
 134              		.thumb
 135              		.thumb_func
 137              	rt_list_isempty:
 138              	.LFB4:
  81:./rt_thread/include/rtservice.h **** 
  82:./rt_thread/include/rtservice.h **** /**
  83:./rt_thread/include/rtservice.h ****  * @brief remove node from list.
  84:./rt_thread/include/rtservice.h ****  * @param n the node to remove from the list.
  85:./rt_thread/include/rtservice.h ****  */
  86:./rt_thread/include/rtservice.h **** rt_inline void rt_list_remove(rt_list_t *n)
  87:./rt_thread/include/rtservice.h **** {
  88:./rt_thread/include/rtservice.h ****     n->next->prev = n->prev;
  89:./rt_thread/include/rtservice.h ****     n->prev->next = n->next;
  90:./rt_thread/include/rtservice.h **** 
  91:./rt_thread/include/rtservice.h ****     n->next = n->prev = n;
  92:./rt_thread/include/rtservice.h **** }
  93:./rt_thread/include/rtservice.h **** 
  94:./rt_thread/include/rtservice.h **** /**
  95:./rt_thread/include/rtservice.h ****  * @brief tests whether a list is empty
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 5


  96:./rt_thread/include/rtservice.h ****  * @param l the list to test.
  97:./rt_thread/include/rtservice.h ****  */
  98:./rt_thread/include/rtservice.h **** rt_inline int rt_list_isempty(const rt_list_t *l)
  99:./rt_thread/include/rtservice.h **** {
 139              		.loc 1 99 1
 140              		.cfi_startproc
 141              		@ args = 0, pretend = 0, frame = 8
 142              		@ frame_needed = 1, uses_anonymous_args = 0
 143              		@ link register save eliminated.
 144 0000 80B4     		push	{r7}
 145              	.LCFI12:
 146              		.cfi_def_cfa_offset 4
 147              		.cfi_offset 7, -4
 148 0002 83B0     		sub	sp, sp, #12
 149              	.LCFI13:
 150              		.cfi_def_cfa_offset 16
 151 0004 00AF     		add	r7, sp, #0
 152              	.LCFI14:
 153              		.cfi_def_cfa_register 7
 154 0006 7860     		str	r0, [r7, #4]
 100:./rt_thread/include/rtservice.h ****     return l->next == l;
 155              		.loc 1 100 13
 156 0008 7B68     		ldr	r3, [r7, #4]
 157 000a 1B68     		ldr	r3, [r3]
 158              		.loc 1 100 20
 159 000c 7A68     		ldr	r2, [r7, #4]
 160 000e 9A42     		cmp	r2, r3
 161 0010 0CBF     		ite	eq
 162 0012 0123     		moveq	r3, #1
 163 0014 0023     		movne	r3, #0
 164 0016 DBB2     		uxtb	r3, r3
 101:./rt_thread/include/rtservice.h **** }
 165              		.loc 1 101 1
 166 0018 1846     		mov	r0, r3
 167 001a 0C37     		adds	r7, r7, #12
 168              	.LCFI15:
 169              		.cfi_def_cfa_offset 4
 170 001c BD46     		mov	sp, r7
 171              	.LCFI16:
 172              		.cfi_def_cfa_register 13
 173              		@ sp needed
 174 001e 80BC     		pop	{r7}
 175              	.LCFI17:
 176              		.cfi_restore 7
 177              		.cfi_def_cfa_offset 0
 178 0020 7047     		bx	lr
 179              		.cfi_endproc
 180              	.LFE4:
 182              		.section	.text.rt_ipc_object_init,"ax",%progbits
 183              		.align	1
 184              		.syntax unified
 185              		.thumb
 186              		.thumb_func
 188              	rt_ipc_object_init:
 189              	.LFB15:
 190              		.file 2 "./rt_thread/src/ipc.c"
   1:./rt_thread/src/ipc.c **** /*
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 6


   2:./rt_thread/src/ipc.c ****  * Copyright (c) 2006-2021, RT-Thread Development Team
   3:./rt_thread/src/ipc.c ****  *
   4:./rt_thread/src/ipc.c ****  * SPDX-License-Identifier: Apache-2.0
   5:./rt_thread/src/ipc.c ****  *
   6:./rt_thread/src/ipc.c ****  * Change Logs:
   7:./rt_thread/src/ipc.c ****  * Date           Author       Notes
   8:./rt_thread/src/ipc.c ****  * 2006-03-14     Bernard      the first version
   9:./rt_thread/src/ipc.c ****  * 2006-04-25     Bernard      implement semaphore
  10:./rt_thread/src/ipc.c ****  * 2006-05-03     Bernard      add RT_IPC_DEBUG
  11:./rt_thread/src/ipc.c ****  *                             modify the type of IPC waiting time to rt_int32_t
  12:./rt_thread/src/ipc.c ****  * 2006-05-10     Bernard      fix the semaphore take bug and add IPC object
  13:./rt_thread/src/ipc.c ****  * 2006-05-12     Bernard      implement mailbox and message queue
  14:./rt_thread/src/ipc.c ****  * 2006-05-20     Bernard      implement mutex
  15:./rt_thread/src/ipc.c ****  * 2006-05-23     Bernard      implement fast event
  16:./rt_thread/src/ipc.c ****  * 2006-05-24     Bernard      implement event
  17:./rt_thread/src/ipc.c ****  * 2006-06-03     Bernard      fix the thread timer init bug
  18:./rt_thread/src/ipc.c ****  * 2006-06-05     Bernard      fix the mutex release bug
  19:./rt_thread/src/ipc.c ****  * 2006-06-07     Bernard      fix the message queue send bug
  20:./rt_thread/src/ipc.c ****  * 2006-08-04     Bernard      add hook support
  21:./rt_thread/src/ipc.c ****  * 2009-05-21     Yi.qiu       fix the sem release bug
  22:./rt_thread/src/ipc.c ****  * 2009-07-18     Bernard      fix the event clear bug
  23:./rt_thread/src/ipc.c ****  * 2009-09-09     Bernard      remove fast event and fix ipc release bug
  24:./rt_thread/src/ipc.c ****  * 2009-10-10     Bernard      change semaphore and mutex value to unsigned value
  25:./rt_thread/src/ipc.c ****  * 2009-10-25     Bernard      change the mb/mq receive timeout to 0 if the
  26:./rt_thread/src/ipc.c ****  *                             re-calculated delta tick is a negative number.
  27:./rt_thread/src/ipc.c ****  * 2009-12-16     Bernard      fix the rt_ipc_object_suspend issue when IPC flag
  28:./rt_thread/src/ipc.c ****  *                             is RT_IPC_FLAG_PRIO
  29:./rt_thread/src/ipc.c ****  * 2010-01-20     mbbill       remove rt_ipc_object_decrease function.
  30:./rt_thread/src/ipc.c ****  * 2010-04-20     Bernard      move memcpy outside interrupt disable in mq
  31:./rt_thread/src/ipc.c ****  * 2010-10-26     yi.qiu       add module support in rt_mp_delete and rt_mq_delete
  32:./rt_thread/src/ipc.c ****  * 2010-11-10     Bernard      add IPC reset command implementation.
  33:./rt_thread/src/ipc.c ****  * 2011-12-18     Bernard      add more parameter checking in message queue
  34:./rt_thread/src/ipc.c ****  * 2013-09-14     Grissiom     add an option check in rt_event_recv
  35:./rt_thread/src/ipc.c ****  * 2018-10-02     Bernard      add 64bit support for mailbox
  36:./rt_thread/src/ipc.c ****  * 2019-09-16     tyx          add send wait support for message queue
  37:./rt_thread/src/ipc.c ****  * 2020-07-29     Meco Man     fix thread->event_set/event_info when received an
  38:./rt_thread/src/ipc.c ****  *                             event without pending
  39:./rt_thread/src/ipc.c ****  * 2020-10-11     Meco Man     add value overflow-check code
  40:./rt_thread/src/ipc.c ****  */
  41:./rt_thread/src/ipc.c **** 
  42:./rt_thread/src/ipc.c **** #include <rtthread.h>
  43:./rt_thread/src/ipc.c **** #include <rthw.h>
  44:./rt_thread/src/ipc.c **** 
  45:./rt_thread/src/ipc.c **** #ifdef RT_USING_HOOK
  46:./rt_thread/src/ipc.c **** extern void (*rt_object_trytake_hook)(struct rt_object *object);
  47:./rt_thread/src/ipc.c **** extern void (*rt_object_take_hook)(struct rt_object *object);
  48:./rt_thread/src/ipc.c **** extern void (*rt_object_put_hook)(struct rt_object *object);
  49:./rt_thread/src/ipc.c **** #endif
  50:./rt_thread/src/ipc.c **** 
  51:./rt_thread/src/ipc.c **** /**
  52:./rt_thread/src/ipc.c ****  * @addtogroup IPC
  53:./rt_thread/src/ipc.c ****  */
  54:./rt_thread/src/ipc.c **** 
  55:./rt_thread/src/ipc.c **** /**@{*/
  56:./rt_thread/src/ipc.c **** 
  57:./rt_thread/src/ipc.c **** /**
  58:./rt_thread/src/ipc.c ****  * This function will initialize an IPC object
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 7


  59:./rt_thread/src/ipc.c ****  *
  60:./rt_thread/src/ipc.c ****  * @param ipc the IPC object
  61:./rt_thread/src/ipc.c ****  *
  62:./rt_thread/src/ipc.c ****  * @return the operation status, RT_EOK on successful
  63:./rt_thread/src/ipc.c ****  */
  64:./rt_thread/src/ipc.c **** rt_inline rt_err_t rt_ipc_object_init(struct rt_ipc_object *ipc)
  65:./rt_thread/src/ipc.c **** {
 191              		.loc 2 65 1
 192              		.cfi_startproc
 193              		@ args = 0, pretend = 0, frame = 8
 194              		@ frame_needed = 1, uses_anonymous_args = 0
 195 0000 80B5     		push	{r7, lr}
 196              	.LCFI18:
 197              		.cfi_def_cfa_offset 8
 198              		.cfi_offset 7, -8
 199              		.cfi_offset 14, -4
 200 0002 82B0     		sub	sp, sp, #8
 201              	.LCFI19:
 202              		.cfi_def_cfa_offset 16
 203 0004 00AF     		add	r7, sp, #0
 204              	.LCFI20:
 205              		.cfi_def_cfa_register 7
 206 0006 7860     		str	r0, [r7, #4]
  66:./rt_thread/src/ipc.c ****     /* initialize ipc object */
  67:./rt_thread/src/ipc.c ****     rt_list_init(&(ipc->suspend_thread));
 207              		.loc 2 67 5
 208 0008 7B68     		ldr	r3, [r7, #4]
 209 000a 1433     		adds	r3, r3, #20
 210 000c 1846     		mov	r0, r3
 211 000e FFF7FEFF 		bl	rt_list_init
  68:./rt_thread/src/ipc.c **** 
  69:./rt_thread/src/ipc.c ****     return RT_EOK;
 212              		.loc 2 69 12
 213 0012 0023     		movs	r3, #0
  70:./rt_thread/src/ipc.c **** }
 214              		.loc 2 70 1
 215 0014 1846     		mov	r0, r3
 216 0016 0837     		adds	r7, r7, #8
 217              	.LCFI21:
 218              		.cfi_def_cfa_offset 8
 219 0018 BD46     		mov	sp, r7
 220              	.LCFI22:
 221              		.cfi_def_cfa_register 13
 222              		@ sp needed
 223 001a 80BD     		pop	{r7, pc}
 224              		.cfi_endproc
 225              	.LFE15:
 227              		.section	.text.rt_ipc_list_suspend,"ax",%progbits
 228              		.align	1
 229              		.syntax unified
 230              		.thumb
 231              		.thumb_func
 233              	rt_ipc_list_suspend:
 234              	.LFB16:
  71:./rt_thread/src/ipc.c **** 
  72:./rt_thread/src/ipc.c **** /**
  73:./rt_thread/src/ipc.c ****  * This function will suspend a thread to a specified list. IPC object or some
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 8


  74:./rt_thread/src/ipc.c ****  * double-queue object (mailbox etc.) contains this kind of list.
  75:./rt_thread/src/ipc.c ****  *
  76:./rt_thread/src/ipc.c ****  * @param list the IPC suspended thread list
  77:./rt_thread/src/ipc.c ****  * @param thread the thread object to be suspended
  78:./rt_thread/src/ipc.c ****  * @param flag the IPC object flag,
  79:./rt_thread/src/ipc.c ****  *        which shall be RT_IPC_FLAG_FIFO/RT_IPC_FLAG_PRIO.
  80:./rt_thread/src/ipc.c ****  *
  81:./rt_thread/src/ipc.c ****  * @return the operation status, RT_EOK on successful
  82:./rt_thread/src/ipc.c ****  */
  83:./rt_thread/src/ipc.c **** rt_inline rt_err_t rt_ipc_list_suspend(rt_list_t        *list,
  84:./rt_thread/src/ipc.c ****                                        struct rt_thread *thread,
  85:./rt_thread/src/ipc.c ****                                        rt_uint8_t        flag)
  86:./rt_thread/src/ipc.c **** {
 235              		.loc 2 86 1
 236              		.cfi_startproc
 237              		@ args = 0, pretend = 0, frame = 24
 238              		@ frame_needed = 1, uses_anonymous_args = 0
 239 0000 80B5     		push	{r7, lr}
 240              	.LCFI23:
 241              		.cfi_def_cfa_offset 8
 242              		.cfi_offset 7, -8
 243              		.cfi_offset 14, -4
 244 0002 86B0     		sub	sp, sp, #24
 245              	.LCFI24:
 246              		.cfi_def_cfa_offset 32
 247 0004 00AF     		add	r7, sp, #0
 248              	.LCFI25:
 249              		.cfi_def_cfa_register 7
 250 0006 F860     		str	r0, [r7, #12]
 251 0008 B960     		str	r1, [r7, #8]
 252 000a 1346     		mov	r3, r2
 253 000c FB71     		strb	r3, [r7, #7]
  87:./rt_thread/src/ipc.c ****     /* suspend thread */
  88:./rt_thread/src/ipc.c ****     rt_thread_suspend(thread);
 254              		.loc 2 88 5
 255 000e B868     		ldr	r0, [r7, #8]
 256 0010 FFF7FEFF 		bl	rt_thread_suspend
  89:./rt_thread/src/ipc.c **** 
  90:./rt_thread/src/ipc.c ****     switch (flag)
 257              		.loc 2 90 5
 258 0014 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 259 0016 002B     		cmp	r3, #0
 260 0018 02D0     		beq	.L8
 261 001a 012B     		cmp	r3, #1
 262 001c 07D0     		beq	.L9
  91:./rt_thread/src/ipc.c ****     {
  92:./rt_thread/src/ipc.c ****     case RT_IPC_FLAG_FIFO:
  93:./rt_thread/src/ipc.c ****         rt_list_insert_before(list, &(thread->tlist));
  94:./rt_thread/src/ipc.c ****         break;
  95:./rt_thread/src/ipc.c **** 
  96:./rt_thread/src/ipc.c ****     case RT_IPC_FLAG_PRIO:
  97:./rt_thread/src/ipc.c ****         {
  98:./rt_thread/src/ipc.c ****             struct rt_list_node *n;
  99:./rt_thread/src/ipc.c ****             struct rt_thread *sthread;
 100:./rt_thread/src/ipc.c **** 
 101:./rt_thread/src/ipc.c ****             /* find a suitable position */
 102:./rt_thread/src/ipc.c ****             for (n = list->next; n != list; n = n->next)
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 9


 103:./rt_thread/src/ipc.c ****             {
 104:./rt_thread/src/ipc.c ****                 sthread = rt_list_entry(n, struct rt_thread, tlist);
 105:./rt_thread/src/ipc.c **** 
 106:./rt_thread/src/ipc.c ****                 /* find out */
 107:./rt_thread/src/ipc.c ****                 if (thread->current_priority < sthread->current_priority)
 108:./rt_thread/src/ipc.c ****                 {
 109:./rt_thread/src/ipc.c ****                     /* insert this thread before the sthread */
 110:./rt_thread/src/ipc.c ****                     rt_list_insert_before(&(sthread->tlist), &(thread->tlist));
 111:./rt_thread/src/ipc.c ****                     break;
 112:./rt_thread/src/ipc.c ****                 }
 113:./rt_thread/src/ipc.c ****             }
 114:./rt_thread/src/ipc.c **** 
 115:./rt_thread/src/ipc.c ****             /*
 116:./rt_thread/src/ipc.c ****              * not found a suitable position,
 117:./rt_thread/src/ipc.c ****              * append to the end of suspend_thread list
 118:./rt_thread/src/ipc.c ****              */
 119:./rt_thread/src/ipc.c ****             if (n == list)
 120:./rt_thread/src/ipc.c ****                 rt_list_insert_before(list, &(thread->tlist));
 121:./rt_thread/src/ipc.c ****         }
 122:./rt_thread/src/ipc.c ****         break;
 123:./rt_thread/src/ipc.c **** 
 124:./rt_thread/src/ipc.c ****     default:
 125:./rt_thread/src/ipc.c ****         break;
 263              		.loc 2 125 9
 264 001e 31E0     		b	.L11
 265              	.L8:
  93:./rt_thread/src/ipc.c ****         break;
 266              		.loc 2 93 9
 267 0020 BB68     		ldr	r3, [r7, #8]
 268 0022 1433     		adds	r3, r3, #20
 269 0024 1946     		mov	r1, r3
 270 0026 F868     		ldr	r0, [r7, #12]
 271 0028 FFF7FEFF 		bl	rt_list_insert_before
  94:./rt_thread/src/ipc.c **** 
 272              		.loc 2 94 9
 273 002c 2AE0     		b	.L11
 274              	.L9:
 275              	.LBB2:
 102:./rt_thread/src/ipc.c ****             {
 276              		.loc 2 102 20
 277 002e FB68     		ldr	r3, [r7, #12]
 278 0030 1B68     		ldr	r3, [r3]
 279 0032 7B61     		str	r3, [r7, #20]
 102:./rt_thread/src/ipc.c ****             {
 280              		.loc 2 102 13
 281 0034 17E0     		b	.L12
 282              	.L15:
 104:./rt_thread/src/ipc.c **** 
 283              		.loc 2 104 25
 284 0036 7B69     		ldr	r3, [r7, #20]
 285 0038 143B     		subs	r3, r3, #20
 286 003a 3B61     		str	r3, [r7, #16]
 107:./rt_thread/src/ipc.c ****                 {
 287              		.loc 2 107 27
 288 003c BB68     		ldr	r3, [r7, #8]
 289 003e 93F83520 		ldrb	r2, [r3, #53]	@ zero_extendqisi2
 107:./rt_thread/src/ipc.c ****                 {
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 10


 290              		.loc 2 107 55
 291 0042 3B69     		ldr	r3, [r7, #16]
 292 0044 93F83530 		ldrb	r3, [r3, #53]	@ zero_extendqisi2
 107:./rt_thread/src/ipc.c ****                 {
 293              		.loc 2 107 20
 294 0048 9A42     		cmp	r2, r3
 295 004a 09D2     		bcs	.L13
 110:./rt_thread/src/ipc.c ****                     break;
 296              		.loc 2 110 21
 297 004c 3B69     		ldr	r3, [r7, #16]
 298 004e 03F11402 		add	r2, r3, #20
 299 0052 BB68     		ldr	r3, [r7, #8]
 300 0054 1433     		adds	r3, r3, #20
 301 0056 1946     		mov	r1, r3
 302 0058 1046     		mov	r0, r2
 303 005a FFF7FEFF 		bl	rt_list_insert_before
 111:./rt_thread/src/ipc.c ****                 }
 304              		.loc 2 111 21
 305 005e 06E0     		b	.L14
 306              	.L13:
 102:./rt_thread/src/ipc.c ****             {
 307              		.loc 2 102 47 discriminator 2
 308 0060 7B69     		ldr	r3, [r7, #20]
 309 0062 1B68     		ldr	r3, [r3]
 310 0064 7B61     		str	r3, [r7, #20]
 311              	.L12:
 102:./rt_thread/src/ipc.c ****             {
 312              		.loc 2 102 13 discriminator 1
 313 0066 7A69     		ldr	r2, [r7, #20]
 314 0068 FB68     		ldr	r3, [r7, #12]
 315 006a 9A42     		cmp	r2, r3
 316 006c E3D1     		bne	.L15
 317              	.L14:
 119:./rt_thread/src/ipc.c ****                 rt_list_insert_before(list, &(thread->tlist));
 318              		.loc 2 119 16
 319 006e 7A69     		ldr	r2, [r7, #20]
 320 0070 FB68     		ldr	r3, [r7, #12]
 321 0072 9A42     		cmp	r2, r3
 322 0074 05D1     		bne	.L18
 120:./rt_thread/src/ipc.c ****         }
 323              		.loc 2 120 17
 324 0076 BB68     		ldr	r3, [r7, #8]
 325 0078 1433     		adds	r3, r3, #20
 326 007a 1946     		mov	r1, r3
 327 007c F868     		ldr	r0, [r7, #12]
 328 007e FFF7FEFF 		bl	rt_list_insert_before
 329              	.L18:
 330              	.LBE2:
 122:./rt_thread/src/ipc.c **** 
 331              		.loc 2 122 9
 332 0082 00BF     		nop
 333              	.L11:
 126:./rt_thread/src/ipc.c ****     }
 127:./rt_thread/src/ipc.c **** 
 128:./rt_thread/src/ipc.c ****     return RT_EOK;
 334              		.loc 2 128 12
 335 0084 0023     		movs	r3, #0
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 11


 129:./rt_thread/src/ipc.c **** }
 336              		.loc 2 129 1
 337 0086 1846     		mov	r0, r3
 338 0088 1837     		adds	r7, r7, #24
 339              	.LCFI26:
 340              		.cfi_def_cfa_offset 8
 341 008a BD46     		mov	sp, r7
 342              	.LCFI27:
 343              		.cfi_def_cfa_register 13
 344              		@ sp needed
 345 008c 80BD     		pop	{r7, pc}
 346              		.cfi_endproc
 347              	.LFE16:
 349              		.section	.text.rt_ipc_list_resume,"ax",%progbits
 350              		.align	1
 351              		.syntax unified
 352              		.thumb
 353              		.thumb_func
 355              	rt_ipc_list_resume:
 356              	.LFB17:
 130:./rt_thread/src/ipc.c **** 
 131:./rt_thread/src/ipc.c **** /**
 132:./rt_thread/src/ipc.c ****  * This function will resume the first thread in the list of a IPC object:
 133:./rt_thread/src/ipc.c ****  * - remove the thread from suspend queue of IPC object
 134:./rt_thread/src/ipc.c ****  * - put the thread into system ready queue
 135:./rt_thread/src/ipc.c ****  *
 136:./rt_thread/src/ipc.c ****  * @param list the thread list
 137:./rt_thread/src/ipc.c ****  *
 138:./rt_thread/src/ipc.c ****  * @return the operation status, RT_EOK on successful
 139:./rt_thread/src/ipc.c ****  */
 140:./rt_thread/src/ipc.c **** rt_inline rt_err_t rt_ipc_list_resume(rt_list_t *list)
 141:./rt_thread/src/ipc.c **** {
 357              		.loc 2 141 1
 358              		.cfi_startproc
 359              		@ args = 0, pretend = 0, frame = 16
 360              		@ frame_needed = 1, uses_anonymous_args = 0
 361 0000 80B5     		push	{r7, lr}
 362              	.LCFI28:
 363              		.cfi_def_cfa_offset 8
 364              		.cfi_offset 7, -8
 365              		.cfi_offset 14, -4
 366 0002 84B0     		sub	sp, sp, #16
 367              	.LCFI29:
 368              		.cfi_def_cfa_offset 24
 369 0004 00AF     		add	r7, sp, #0
 370              	.LCFI30:
 371              		.cfi_def_cfa_register 7
 372 0006 7860     		str	r0, [r7, #4]
 142:./rt_thread/src/ipc.c ****     struct rt_thread *thread;
 143:./rt_thread/src/ipc.c **** 
 144:./rt_thread/src/ipc.c ****     /* get thread entry */
 145:./rt_thread/src/ipc.c ****     thread = rt_list_entry(list->next, struct rt_thread, tlist);
 373              		.loc 2 145 14
 374 0008 7B68     		ldr	r3, [r7, #4]
 375 000a 1B68     		ldr	r3, [r3]
 376              		.loc 2 145 12
 377 000c 143B     		subs	r3, r3, #20
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 12


 378 000e FB60     		str	r3, [r7, #12]
 146:./rt_thread/src/ipc.c **** 
 147:./rt_thread/src/ipc.c ****     RT_DEBUG_LOG(RT_DEBUG_IPC, ("resume thread:%s\n", thread->name));
 148:./rt_thread/src/ipc.c **** 
 149:./rt_thread/src/ipc.c ****     /* resume it */
 150:./rt_thread/src/ipc.c ****     rt_thread_resume(thread);
 379              		.loc 2 150 5
 380 0010 F868     		ldr	r0, [r7, #12]
 381 0012 FFF7FEFF 		bl	rt_thread_resume
 151:./rt_thread/src/ipc.c **** 
 152:./rt_thread/src/ipc.c ****     return RT_EOK;
 382              		.loc 2 152 12
 383 0016 0023     		movs	r3, #0
 153:./rt_thread/src/ipc.c **** }
 384              		.loc 2 153 1
 385 0018 1846     		mov	r0, r3
 386 001a 1037     		adds	r7, r7, #16
 387              	.LCFI31:
 388              		.cfi_def_cfa_offset 8
 389 001c BD46     		mov	sp, r7
 390              	.LCFI32:
 391              		.cfi_def_cfa_register 13
 392              		@ sp needed
 393 001e 80BD     		pop	{r7, pc}
 394              		.cfi_endproc
 395              	.LFE17:
 397              		.section	.text.rt_ipc_list_resume_all,"ax",%progbits
 398              		.align	1
 399              		.syntax unified
 400              		.thumb
 401              		.thumb_func
 403              	rt_ipc_list_resume_all:
 404              	.LFB18:
 154:./rt_thread/src/ipc.c **** 
 155:./rt_thread/src/ipc.c **** /**
 156:./rt_thread/src/ipc.c ****  * This function will resume all suspended threads in a list, including
 157:./rt_thread/src/ipc.c ****  * suspend list of IPC object and private list of mailbox etc.
 158:./rt_thread/src/ipc.c ****  *
 159:./rt_thread/src/ipc.c ****  * @param list of the threads to resume
 160:./rt_thread/src/ipc.c ****  *
 161:./rt_thread/src/ipc.c ****  * @return the operation status, RT_EOK on successful
 162:./rt_thread/src/ipc.c ****  */
 163:./rt_thread/src/ipc.c **** rt_inline rt_err_t rt_ipc_list_resume_all(rt_list_t *list)
 164:./rt_thread/src/ipc.c **** {
 405              		.loc 2 164 1
 406              		.cfi_startproc
 407              		@ args = 0, pretend = 0, frame = 16
 408              		@ frame_needed = 1, uses_anonymous_args = 0
 409 0000 90B5     		push	{r4, r7, lr}
 410              	.LCFI33:
 411              		.cfi_def_cfa_offset 12
 412              		.cfi_offset 4, -12
 413              		.cfi_offset 7, -8
 414              		.cfi_offset 14, -4
 415 0002 85B0     		sub	sp, sp, #20
 416              	.LCFI34:
 417              		.cfi_def_cfa_offset 32
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 13


 418 0004 00AF     		add	r7, sp, #0
 419              	.LCFI35:
 420              		.cfi_def_cfa_register 7
 421 0006 7860     		str	r0, [r7, #4]
 165:./rt_thread/src/ipc.c ****     struct rt_thread *thread;
 166:./rt_thread/src/ipc.c ****     register rt_ubase_t temp;
 167:./rt_thread/src/ipc.c **** 
 168:./rt_thread/src/ipc.c ****     /* wakeup all suspended threads */
 169:./rt_thread/src/ipc.c ****     while (!rt_list_isempty(list))
 422              		.loc 2 169 11
 423 0008 12E0     		b	.L22
 424              	.L23:
 170:./rt_thread/src/ipc.c ****     {
 171:./rt_thread/src/ipc.c ****         /* disable interrupt */
 172:./rt_thread/src/ipc.c ****         temp = rt_hw_interrupt_disable();
 425              		.loc 2 172 16
 426 000a FFF7FEFF 		bl	rt_hw_interrupt_disable
 427 000e 0346     		mov	r3, r0
 428              		.loc 2 172 14
 429 0010 1C46     		mov	r4, r3
 173:./rt_thread/src/ipc.c **** 
 174:./rt_thread/src/ipc.c ****         /* get next suspended thread */
 175:./rt_thread/src/ipc.c ****         thread = rt_list_entry(list->next, struct rt_thread, tlist);
 430              		.loc 2 175 18
 431 0012 7B68     		ldr	r3, [r7, #4]
 432 0014 1B68     		ldr	r3, [r3]
 433              		.loc 2 175 16
 434 0016 143B     		subs	r3, r3, #20
 435 0018 FB60     		str	r3, [r7, #12]
 176:./rt_thread/src/ipc.c ****         /* set error code to RT_ERROR */
 177:./rt_thread/src/ipc.c ****         thread->error = -RT_ERROR;
 436              		.loc 2 177 23
 437 001a FB68     		ldr	r3, [r7, #12]
 438 001c 4FF0FF32 		mov	r2, #-1
 439 0020 1A63     		str	r2, [r3, #48]
 178:./rt_thread/src/ipc.c **** 
 179:./rt_thread/src/ipc.c ****         /*
 180:./rt_thread/src/ipc.c ****          * resume thread
 181:./rt_thread/src/ipc.c ****          * In rt_thread_resume function, it will remove current thread from
 182:./rt_thread/src/ipc.c ****          * suspended list
 183:./rt_thread/src/ipc.c ****          */
 184:./rt_thread/src/ipc.c ****         rt_thread_resume(thread);
 440              		.loc 2 184 9
 441 0022 F868     		ldr	r0, [r7, #12]
 442 0024 FFF7FEFF 		bl	rt_thread_resume
 185:./rt_thread/src/ipc.c **** 
 186:./rt_thread/src/ipc.c ****         /* enable interrupt */
 187:./rt_thread/src/ipc.c ****         rt_hw_interrupt_enable(temp);
 443              		.loc 2 187 9
 444 0028 2346     		mov	r3, r4
 445 002a 1846     		mov	r0, r3
 446 002c FFF7FEFF 		bl	rt_hw_interrupt_enable
 447              	.L22:
 169:./rt_thread/src/ipc.c ****     {
 448              		.loc 2 169 13
 449 0030 7868     		ldr	r0, [r7, #4]
 450 0032 FFF7FEFF 		bl	rt_list_isempty
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 14


 451 0036 0346     		mov	r3, r0
 169:./rt_thread/src/ipc.c ****     {
 452              		.loc 2 169 11
 453 0038 002B     		cmp	r3, #0
 454 003a E6D0     		beq	.L23
 188:./rt_thread/src/ipc.c ****     }
 189:./rt_thread/src/ipc.c **** 
 190:./rt_thread/src/ipc.c ****     return RT_EOK;
 455              		.loc 2 190 12
 456 003c 0023     		movs	r3, #0
 191:./rt_thread/src/ipc.c **** }
 457              		.loc 2 191 1
 458 003e 1846     		mov	r0, r3
 459 0040 1437     		adds	r7, r7, #20
 460              	.LCFI36:
 461              		.cfi_def_cfa_offset 12
 462 0042 BD46     		mov	sp, r7
 463              	.LCFI37:
 464              		.cfi_def_cfa_register 13
 465              		@ sp needed
 466 0044 90BD     		pop	{r4, r7, pc}
 467              		.cfi_endproc
 468              	.LFE18:
 470              		.section	.text.rt_sem_init,"ax",%progbits
 471              		.align	1
 472              		.global	rt_sem_init
 473              		.syntax unified
 474              		.thumb
 475              		.thumb_func
 477              	rt_sem_init:
 478              	.LFB19:
 192:./rt_thread/src/ipc.c **** 
 193:./rt_thread/src/ipc.c **** #ifdef RT_USING_SEMAPHORE
 194:./rt_thread/src/ipc.c **** /**
 195:./rt_thread/src/ipc.c ****  * This function will initialize a semaphore and put it under control of
 196:./rt_thread/src/ipc.c ****  * resource management.
 197:./rt_thread/src/ipc.c ****  *
 198:./rt_thread/src/ipc.c ****  * @param sem the semaphore object
 199:./rt_thread/src/ipc.c ****  * @param name the name of semaphore
 200:./rt_thread/src/ipc.c ****  * @param value the initial value of semaphore
 201:./rt_thread/src/ipc.c ****  * @param flag the flag of semaphore
 202:./rt_thread/src/ipc.c ****  *
 203:./rt_thread/src/ipc.c ****  * @return the operation status, RT_EOK on successful
 204:./rt_thread/src/ipc.c ****  */
 205:./rt_thread/src/ipc.c **** rt_err_t rt_sem_init(rt_sem_t    sem,
 206:./rt_thread/src/ipc.c ****                      const char *name,
 207:./rt_thread/src/ipc.c ****                      rt_uint32_t value,
 208:./rt_thread/src/ipc.c ****                      rt_uint8_t  flag)
 209:./rt_thread/src/ipc.c **** {
 479              		.loc 2 209 1
 480              		.cfi_startproc
 481              		@ args = 0, pretend = 0, frame = 16
 482              		@ frame_needed = 1, uses_anonymous_args = 0
 483 0000 80B5     		push	{r7, lr}
 484              	.LCFI38:
 485              		.cfi_def_cfa_offset 8
 486              		.cfi_offset 7, -8
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 15


 487              		.cfi_offset 14, -4
 488 0002 84B0     		sub	sp, sp, #16
 489              	.LCFI39:
 490              		.cfi_def_cfa_offset 24
 491 0004 00AF     		add	r7, sp, #0
 492              	.LCFI40:
 493              		.cfi_def_cfa_register 7
 494 0006 F860     		str	r0, [r7, #12]
 495 0008 B960     		str	r1, [r7, #8]
 496 000a 7A60     		str	r2, [r7, #4]
 497 000c FB70     		strb	r3, [r7, #3]
 210:./rt_thread/src/ipc.c ****     RT_ASSERT(sem != RT_NULL);
 211:./rt_thread/src/ipc.c ****     RT_ASSERT(value < 0x10000U);
 212:./rt_thread/src/ipc.c **** 
 213:./rt_thread/src/ipc.c ****     /* initialize object */
 214:./rt_thread/src/ipc.c ****     rt_object_init(&(sem->parent.parent), RT_Object_Class_Semaphore, name);
 498              		.loc 2 214 5
 499 000e FB68     		ldr	r3, [r7, #12]
 500 0010 BA68     		ldr	r2, [r7, #8]
 501 0012 0221     		movs	r1, #2
 502 0014 1846     		mov	r0, r3
 503 0016 FFF7FEFF 		bl	rt_object_init
 215:./rt_thread/src/ipc.c **** 
 216:./rt_thread/src/ipc.c ****     /* initialize ipc object */
 217:./rt_thread/src/ipc.c ****     rt_ipc_object_init(&(sem->parent));
 504              		.loc 2 217 5
 505 001a FB68     		ldr	r3, [r7, #12]
 506 001c 1846     		mov	r0, r3
 507 001e FFF7FEFF 		bl	rt_ipc_object_init
 218:./rt_thread/src/ipc.c **** 
 219:./rt_thread/src/ipc.c ****     /* set initial value */
 220:./rt_thread/src/ipc.c ****     sem->value = (rt_uint16_t)value;
 508              		.loc 2 220 18
 509 0022 7B68     		ldr	r3, [r7, #4]
 510 0024 9AB2     		uxth	r2, r3
 511              		.loc 2 220 16
 512 0026 FB68     		ldr	r3, [r7, #12]
 513 0028 9A83     		strh	r2, [r3, #28]	@ movhi
 221:./rt_thread/src/ipc.c **** 
 222:./rt_thread/src/ipc.c ****     /* set parent */
 223:./rt_thread/src/ipc.c ****     sem->parent.parent.flag = flag;
 514              		.loc 2 223 29
 515 002a FB68     		ldr	r3, [r7, #12]
 516 002c FA78     		ldrb	r2, [r7, #3]
 517 002e 5A72     		strb	r2, [r3, #9]
 224:./rt_thread/src/ipc.c **** 
 225:./rt_thread/src/ipc.c ****     return RT_EOK;
 518              		.loc 2 225 12
 519 0030 0023     		movs	r3, #0
 226:./rt_thread/src/ipc.c **** }
 520              		.loc 2 226 1
 521 0032 1846     		mov	r0, r3
 522 0034 1037     		adds	r7, r7, #16
 523              	.LCFI41:
 524              		.cfi_def_cfa_offset 8
 525 0036 BD46     		mov	sp, r7
 526              	.LCFI42:
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 16


 527              		.cfi_def_cfa_register 13
 528              		@ sp needed
 529 0038 80BD     		pop	{r7, pc}
 530              		.cfi_endproc
 531              	.LFE19:
 533              		.section	.text.rt_sem_detach,"ax",%progbits
 534              		.align	1
 535              		.global	rt_sem_detach
 536              		.syntax unified
 537              		.thumb
 538              		.thumb_func
 540              	rt_sem_detach:
 541              	.LFB20:
 227:./rt_thread/src/ipc.c **** 
 228:./rt_thread/src/ipc.c **** /**
 229:./rt_thread/src/ipc.c ****  * This function will detach a semaphore from resource management
 230:./rt_thread/src/ipc.c ****  *
 231:./rt_thread/src/ipc.c ****  * @param sem the semaphore object
 232:./rt_thread/src/ipc.c ****  *
 233:./rt_thread/src/ipc.c ****  * @return the operation status, RT_EOK on successful
 234:./rt_thread/src/ipc.c ****  *
 235:./rt_thread/src/ipc.c ****  * @see rt_sem_delete
 236:./rt_thread/src/ipc.c ****  */
 237:./rt_thread/src/ipc.c **** rt_err_t rt_sem_detach(rt_sem_t sem)
 238:./rt_thread/src/ipc.c **** {
 542              		.loc 2 238 1
 543              		.cfi_startproc
 544              		@ args = 0, pretend = 0, frame = 8
 545              		@ frame_needed = 1, uses_anonymous_args = 0
 546 0000 80B5     		push	{r7, lr}
 547              	.LCFI43:
 548              		.cfi_def_cfa_offset 8
 549              		.cfi_offset 7, -8
 550              		.cfi_offset 14, -4
 551 0002 82B0     		sub	sp, sp, #8
 552              	.LCFI44:
 553              		.cfi_def_cfa_offset 16
 554 0004 00AF     		add	r7, sp, #0
 555              	.LCFI45:
 556              		.cfi_def_cfa_register 7
 557 0006 7860     		str	r0, [r7, #4]
 239:./rt_thread/src/ipc.c ****     /* parameter check */
 240:./rt_thread/src/ipc.c ****     RT_ASSERT(sem != RT_NULL);
 241:./rt_thread/src/ipc.c ****     RT_ASSERT(rt_object_get_type(&sem->parent.parent) == RT_Object_Class_Semaphore);
 242:./rt_thread/src/ipc.c ****     RT_ASSERT(rt_object_is_systemobject(&sem->parent.parent));
 243:./rt_thread/src/ipc.c **** 
 244:./rt_thread/src/ipc.c ****     /* wakeup all suspended threads */
 245:./rt_thread/src/ipc.c ****     rt_ipc_list_resume_all(&(sem->parent.suspend_thread));
 558              		.loc 2 245 5
 559 0008 7B68     		ldr	r3, [r7, #4]
 560 000a 1433     		adds	r3, r3, #20
 561 000c 1846     		mov	r0, r3
 562 000e FFF7FEFF 		bl	rt_ipc_list_resume_all
 246:./rt_thread/src/ipc.c **** 
 247:./rt_thread/src/ipc.c ****     /* detach semaphore object */
 248:./rt_thread/src/ipc.c ****     rt_object_detach(&(sem->parent.parent));
 563              		.loc 2 248 5
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 17


 564 0012 7B68     		ldr	r3, [r7, #4]
 565 0014 1846     		mov	r0, r3
 566 0016 FFF7FEFF 		bl	rt_object_detach
 249:./rt_thread/src/ipc.c **** 
 250:./rt_thread/src/ipc.c ****     return RT_EOK;
 567              		.loc 2 250 12
 568 001a 0023     		movs	r3, #0
 251:./rt_thread/src/ipc.c **** }
 569              		.loc 2 251 1
 570 001c 1846     		mov	r0, r3
 571 001e 0837     		adds	r7, r7, #8
 572              	.LCFI46:
 573              		.cfi_def_cfa_offset 8
 574 0020 BD46     		mov	sp, r7
 575              	.LCFI47:
 576              		.cfi_def_cfa_register 13
 577              		@ sp needed
 578 0022 80BD     		pop	{r7, pc}
 579              		.cfi_endproc
 580              	.LFE20:
 582              		.section	.text.rt_sem_create,"ax",%progbits
 583              		.align	1
 584              		.global	rt_sem_create
 585              		.syntax unified
 586              		.thumb
 587              		.thumb_func
 589              	rt_sem_create:
 590              	.LFB21:
 252:./rt_thread/src/ipc.c **** 
 253:./rt_thread/src/ipc.c **** #ifdef RT_USING_HEAP
 254:./rt_thread/src/ipc.c **** /**
 255:./rt_thread/src/ipc.c ****  * This function will create a semaphore from system resource
 256:./rt_thread/src/ipc.c ****  *
 257:./rt_thread/src/ipc.c ****  * @param name the name of semaphore
 258:./rt_thread/src/ipc.c ****  * @param value the initial value of semaphore
 259:./rt_thread/src/ipc.c ****  * @param flag the flag of semaphore
 260:./rt_thread/src/ipc.c ****  *
 261:./rt_thread/src/ipc.c ****  * @return the created semaphore, RT_NULL on error happen
 262:./rt_thread/src/ipc.c ****  *
 263:./rt_thread/src/ipc.c ****  * @see rt_sem_init
 264:./rt_thread/src/ipc.c ****  */
 265:./rt_thread/src/ipc.c **** rt_sem_t rt_sem_create(const char *name, rt_uint32_t value, rt_uint8_t flag)
 266:./rt_thread/src/ipc.c **** {
 591              		.loc 2 266 1
 592              		.cfi_startproc
 593              		@ args = 0, pretend = 0, frame = 24
 594              		@ frame_needed = 1, uses_anonymous_args = 0
 595 0000 80B5     		push	{r7, lr}
 596              	.LCFI48:
 597              		.cfi_def_cfa_offset 8
 598              		.cfi_offset 7, -8
 599              		.cfi_offset 14, -4
 600 0002 86B0     		sub	sp, sp, #24
 601              	.LCFI49:
 602              		.cfi_def_cfa_offset 32
 603 0004 00AF     		add	r7, sp, #0
 604              	.LCFI50:
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 18


 605              		.cfi_def_cfa_register 7
 606 0006 F860     		str	r0, [r7, #12]
 607 0008 B960     		str	r1, [r7, #8]
 608 000a 1346     		mov	r3, r2
 609 000c FB71     		strb	r3, [r7, #7]
 267:./rt_thread/src/ipc.c ****     rt_sem_t sem;
 268:./rt_thread/src/ipc.c **** 
 269:./rt_thread/src/ipc.c ****     RT_DEBUG_NOT_IN_INTERRUPT;
 270:./rt_thread/src/ipc.c ****     RT_ASSERT(value < 0x10000U);
 271:./rt_thread/src/ipc.c **** 
 272:./rt_thread/src/ipc.c ****     /* allocate object */
 273:./rt_thread/src/ipc.c ****     sem = (rt_sem_t)rt_object_allocate(RT_Object_Class_Semaphore, name);
 610              		.loc 2 273 21
 611 000e F968     		ldr	r1, [r7, #12]
 612 0010 0220     		movs	r0, #2
 613 0012 FFF7FEFF 		bl	rt_object_allocate
 614 0016 7861     		str	r0, [r7, #20]
 274:./rt_thread/src/ipc.c ****     if (sem == RT_NULL)
 615              		.loc 2 274 8
 616 0018 7B69     		ldr	r3, [r7, #20]
 617 001a 002B     		cmp	r3, #0
 618 001c 01D1     		bne	.L30
 275:./rt_thread/src/ipc.c ****         return sem;
 619              		.loc 2 275 16
 620 001e 7B69     		ldr	r3, [r7, #20]
 621 0020 0BE0     		b	.L31
 622              	.L30:
 276:./rt_thread/src/ipc.c **** 
 277:./rt_thread/src/ipc.c ****     /* initialize ipc object */
 278:./rt_thread/src/ipc.c ****     rt_ipc_object_init(&(sem->parent));
 623              		.loc 2 278 5
 624 0022 7B69     		ldr	r3, [r7, #20]
 625 0024 1846     		mov	r0, r3
 626 0026 FFF7FEFF 		bl	rt_ipc_object_init
 279:./rt_thread/src/ipc.c **** 
 280:./rt_thread/src/ipc.c ****     /* set initial value */
 281:./rt_thread/src/ipc.c ****     sem->value = value;
 627              		.loc 2 281 16
 628 002a BB68     		ldr	r3, [r7, #8]
 629 002c 9AB2     		uxth	r2, r3
 630 002e 7B69     		ldr	r3, [r7, #20]
 631 0030 9A83     		strh	r2, [r3, #28]	@ movhi
 282:./rt_thread/src/ipc.c **** 
 283:./rt_thread/src/ipc.c ****     /* set parent */
 284:./rt_thread/src/ipc.c ****     sem->parent.parent.flag = flag;
 632              		.loc 2 284 29
 633 0032 7B69     		ldr	r3, [r7, #20]
 634 0034 FA79     		ldrb	r2, [r7, #7]
 635 0036 5A72     		strb	r2, [r3, #9]
 285:./rt_thread/src/ipc.c **** 
 286:./rt_thread/src/ipc.c ****     return sem;
 636              		.loc 2 286 12
 637 0038 7B69     		ldr	r3, [r7, #20]
 638              	.L31:
 287:./rt_thread/src/ipc.c **** }
 639              		.loc 2 287 1
 640 003a 1846     		mov	r0, r3
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 19


 641 003c 1837     		adds	r7, r7, #24
 642              	.LCFI51:
 643              		.cfi_def_cfa_offset 8
 644 003e BD46     		mov	sp, r7
 645              	.LCFI52:
 646              		.cfi_def_cfa_register 13
 647              		@ sp needed
 648 0040 80BD     		pop	{r7, pc}
 649              		.cfi_endproc
 650              	.LFE21:
 652              		.section	.text.rt_sem_delete,"ax",%progbits
 653              		.align	1
 654              		.global	rt_sem_delete
 655              		.syntax unified
 656              		.thumb
 657              		.thumb_func
 659              	rt_sem_delete:
 660              	.LFB22:
 288:./rt_thread/src/ipc.c **** 
 289:./rt_thread/src/ipc.c **** /**
 290:./rt_thread/src/ipc.c ****  * This function will delete a semaphore object and release the memory
 291:./rt_thread/src/ipc.c ****  *
 292:./rt_thread/src/ipc.c ****  * @param sem the semaphore object
 293:./rt_thread/src/ipc.c ****  *
 294:./rt_thread/src/ipc.c ****  * @return the error code
 295:./rt_thread/src/ipc.c ****  *
 296:./rt_thread/src/ipc.c ****  * @see rt_sem_detach
 297:./rt_thread/src/ipc.c ****  */
 298:./rt_thread/src/ipc.c **** rt_err_t rt_sem_delete(rt_sem_t sem)
 299:./rt_thread/src/ipc.c **** {
 661              		.loc 2 299 1
 662              		.cfi_startproc
 663              		@ args = 0, pretend = 0, frame = 8
 664              		@ frame_needed = 1, uses_anonymous_args = 0
 665 0000 80B5     		push	{r7, lr}
 666              	.LCFI53:
 667              		.cfi_def_cfa_offset 8
 668              		.cfi_offset 7, -8
 669              		.cfi_offset 14, -4
 670 0002 82B0     		sub	sp, sp, #8
 671              	.LCFI54:
 672              		.cfi_def_cfa_offset 16
 673 0004 00AF     		add	r7, sp, #0
 674              	.LCFI55:
 675              		.cfi_def_cfa_register 7
 676 0006 7860     		str	r0, [r7, #4]
 300:./rt_thread/src/ipc.c ****     RT_DEBUG_NOT_IN_INTERRUPT;
 301:./rt_thread/src/ipc.c **** 
 302:./rt_thread/src/ipc.c ****     /* parameter check */
 303:./rt_thread/src/ipc.c ****     RT_ASSERT(sem != RT_NULL);
 304:./rt_thread/src/ipc.c ****     RT_ASSERT(rt_object_get_type(&sem->parent.parent) == RT_Object_Class_Semaphore);
 305:./rt_thread/src/ipc.c ****     RT_ASSERT(rt_object_is_systemobject(&sem->parent.parent) == RT_FALSE);
 306:./rt_thread/src/ipc.c **** 
 307:./rt_thread/src/ipc.c ****     /* wakeup all suspended threads */
 308:./rt_thread/src/ipc.c ****     rt_ipc_list_resume_all(&(sem->parent.suspend_thread));
 677              		.loc 2 308 5
 678 0008 7B68     		ldr	r3, [r7, #4]
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 20


 679 000a 1433     		adds	r3, r3, #20
 680 000c 1846     		mov	r0, r3
 681 000e FFF7FEFF 		bl	rt_ipc_list_resume_all
 309:./rt_thread/src/ipc.c **** 
 310:./rt_thread/src/ipc.c ****     /* delete semaphore object */
 311:./rt_thread/src/ipc.c ****     rt_object_delete(&(sem->parent.parent));
 682              		.loc 2 311 5
 683 0012 7B68     		ldr	r3, [r7, #4]
 684 0014 1846     		mov	r0, r3
 685 0016 FFF7FEFF 		bl	rt_object_delete
 312:./rt_thread/src/ipc.c **** 
 313:./rt_thread/src/ipc.c ****     return RT_EOK;
 686              		.loc 2 313 12
 687 001a 0023     		movs	r3, #0
 314:./rt_thread/src/ipc.c **** }
 688              		.loc 2 314 1
 689 001c 1846     		mov	r0, r3
 690 001e 0837     		adds	r7, r7, #8
 691              	.LCFI56:
 692              		.cfi_def_cfa_offset 8
 693 0020 BD46     		mov	sp, r7
 694              	.LCFI57:
 695              		.cfi_def_cfa_register 13
 696              		@ sp needed
 697 0022 80BD     		pop	{r7, pc}
 698              		.cfi_endproc
 699              	.LFE22:
 701              		.section	.text.rt_sem_take,"ax",%progbits
 702              		.align	1
 703              		.global	rt_sem_take
 704              		.syntax unified
 705              		.thumb
 706              		.thumb_func
 708              	rt_sem_take:
 709              	.LFB23:
 315:./rt_thread/src/ipc.c **** #endif
 316:./rt_thread/src/ipc.c **** 
 317:./rt_thread/src/ipc.c **** /**
 318:./rt_thread/src/ipc.c ****  * This function will take a semaphore, if the semaphore is unavailable, the
 319:./rt_thread/src/ipc.c ****  * thread shall wait for a specified time.
 320:./rt_thread/src/ipc.c ****  *
 321:./rt_thread/src/ipc.c ****  * @param sem the semaphore object
 322:./rt_thread/src/ipc.c ****  * @param time the waiting time
 323:./rt_thread/src/ipc.c ****  *
 324:./rt_thread/src/ipc.c ****  * @return the error code
 325:./rt_thread/src/ipc.c ****  */
 326:./rt_thread/src/ipc.c **** rt_err_t rt_sem_take(rt_sem_t sem, rt_int32_t time)
 327:./rt_thread/src/ipc.c **** {
 710              		.loc 2 327 1
 711              		.cfi_startproc
 712              		@ args = 0, pretend = 0, frame = 16
 713              		@ frame_needed = 1, uses_anonymous_args = 0
 714 0000 90B5     		push	{r4, r7, lr}
 715              	.LCFI58:
 716              		.cfi_def_cfa_offset 12
 717              		.cfi_offset 4, -12
 718              		.cfi_offset 7, -8
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 21


 719              		.cfi_offset 14, -4
 720 0002 85B0     		sub	sp, sp, #20
 721              	.LCFI59:
 722              		.cfi_def_cfa_offset 32
 723 0004 00AF     		add	r7, sp, #0
 724              	.LCFI60:
 725              		.cfi_def_cfa_register 7
 726 0006 7860     		str	r0, [r7, #4]
 727 0008 3960     		str	r1, [r7]
 328:./rt_thread/src/ipc.c ****     register rt_base_t temp;
 329:./rt_thread/src/ipc.c ****     struct rt_thread *thread;
 330:./rt_thread/src/ipc.c **** 
 331:./rt_thread/src/ipc.c ****     /* parameter check */
 332:./rt_thread/src/ipc.c ****     RT_ASSERT(sem != RT_NULL);
 333:./rt_thread/src/ipc.c ****     RT_ASSERT(rt_object_get_type(&sem->parent.parent) == RT_Object_Class_Semaphore);
 334:./rt_thread/src/ipc.c **** 
 335:./rt_thread/src/ipc.c ****     RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(sem->parent.parent)));
 336:./rt_thread/src/ipc.c **** 
 337:./rt_thread/src/ipc.c ****     /* disable interrupt */
 338:./rt_thread/src/ipc.c ****     temp = rt_hw_interrupt_disable();
 728              		.loc 2 338 12
 729 000a FFF7FEFF 		bl	rt_hw_interrupt_disable
 730 000e 0446     		mov	r4, r0
 339:./rt_thread/src/ipc.c **** 
 340:./rt_thread/src/ipc.c ****     RT_DEBUG_LOG(RT_DEBUG_IPC, ("thread %s take sem:%s, which value is: %d\n",
 341:./rt_thread/src/ipc.c ****                                 rt_thread_self()->name,
 342:./rt_thread/src/ipc.c ****                                 ((struct rt_object *)sem)->name,
 343:./rt_thread/src/ipc.c ****                                 sem->value));
 344:./rt_thread/src/ipc.c **** 
 345:./rt_thread/src/ipc.c ****     if (sem->value > 0)
 731              		.loc 2 345 12
 732 0010 7B68     		ldr	r3, [r7, #4]
 733 0012 9B8B     		ldrh	r3, [r3, #28]
 734              		.loc 2 345 8
 735 0014 002B     		cmp	r3, #0
 736 0016 09D0     		beq	.L35
 346:./rt_thread/src/ipc.c ****     {
 347:./rt_thread/src/ipc.c ****         /* semaphore is available */
 348:./rt_thread/src/ipc.c ****         sem->value --;
 737              		.loc 2 348 12
 738 0018 7B68     		ldr	r3, [r7, #4]
 739 001a 9B8B     		ldrh	r3, [r3, #28]
 740              		.loc 2 348 20
 741 001c 013B     		subs	r3, r3, #1
 742 001e 9AB2     		uxth	r2, r3
 743 0020 7B68     		ldr	r3, [r7, #4]
 744 0022 9A83     		strh	r2, [r3, #28]	@ movhi
 349:./rt_thread/src/ipc.c **** 
 350:./rt_thread/src/ipc.c ****         /* enable interrupt */
 351:./rt_thread/src/ipc.c ****         rt_hw_interrupt_enable(temp);
 745              		.loc 2 351 9
 746 0024 2046     		mov	r0, r4
 747 0026 FFF7FEFF 		bl	rt_hw_interrupt_enable
 748 002a 32E0     		b	.L36
 749              	.L35:
 352:./rt_thread/src/ipc.c ****     }
 353:./rt_thread/src/ipc.c ****     else
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 22


 354:./rt_thread/src/ipc.c ****     {
 355:./rt_thread/src/ipc.c ****         /* no waiting, return with timeout */
 356:./rt_thread/src/ipc.c ****         if (time == 0)
 750              		.loc 2 356 18
 751 002c 3B68     		ldr	r3, [r7]
 752              		.loc 2 356 12
 753 002e 002B     		cmp	r3, #0
 754 0030 05D1     		bne	.L37
 357:./rt_thread/src/ipc.c ****         {
 358:./rt_thread/src/ipc.c ****             rt_hw_interrupt_enable(temp);
 755              		.loc 2 358 13
 756 0032 2046     		mov	r0, r4
 757 0034 FFF7FEFF 		bl	rt_hw_interrupt_enable
 359:./rt_thread/src/ipc.c **** 
 360:./rt_thread/src/ipc.c ****             return -RT_ETIMEOUT;
 758              		.loc 2 360 20
 759 0038 6FF00103 		mvn	r3, #1
 760 003c 2AE0     		b	.L38
 761              	.L37:
 361:./rt_thread/src/ipc.c ****         }
 362:./rt_thread/src/ipc.c ****         else
 363:./rt_thread/src/ipc.c ****         {
 364:./rt_thread/src/ipc.c ****             /* current context checking */
 365:./rt_thread/src/ipc.c ****             RT_DEBUG_IN_THREAD_CONTEXT;
 366:./rt_thread/src/ipc.c **** 
 367:./rt_thread/src/ipc.c ****             /* semaphore is unavailable, push to suspend list */
 368:./rt_thread/src/ipc.c ****             /* get current thread */
 369:./rt_thread/src/ipc.c ****             thread = rt_thread_self();
 762              		.loc 2 369 22
 763 003e FFF7FEFF 		bl	rt_thread_self
 764 0042 F860     		str	r0, [r7, #12]
 370:./rt_thread/src/ipc.c **** 
 371:./rt_thread/src/ipc.c ****             /* reset thread error number */
 372:./rt_thread/src/ipc.c ****             thread->error = RT_EOK;
 765              		.loc 2 372 27
 766 0044 FB68     		ldr	r3, [r7, #12]
 767 0046 0022     		movs	r2, #0
 768 0048 1A63     		str	r2, [r3, #48]
 373:./rt_thread/src/ipc.c **** 
 374:./rt_thread/src/ipc.c ****             RT_DEBUG_LOG(RT_DEBUG_IPC, ("sem take: suspend thread - %s\n",
 375:./rt_thread/src/ipc.c ****                                         thread->name));
 376:./rt_thread/src/ipc.c **** 
 377:./rt_thread/src/ipc.c ****             /* suspend thread */
 378:./rt_thread/src/ipc.c ****             rt_ipc_list_suspend(&(sem->parent.suspend_thread),
 769              		.loc 2 378 13
 770 004a 7B68     		ldr	r3, [r7, #4]
 771 004c 03F11400 		add	r0, r3, #20
 772 0050 7B68     		ldr	r3, [r7, #4]
 773 0052 5B7A     		ldrb	r3, [r3, #9]	@ zero_extendqisi2
 774 0054 1A46     		mov	r2, r3
 775 0056 F968     		ldr	r1, [r7, #12]
 776 0058 FFF7FEFF 		bl	rt_ipc_list_suspend
 379:./rt_thread/src/ipc.c ****                                 thread,
 380:./rt_thread/src/ipc.c ****                                 sem->parent.parent.flag);
 381:./rt_thread/src/ipc.c **** 
 382:./rt_thread/src/ipc.c ****             /* has waiting time, start thread timer */
 383:./rt_thread/src/ipc.c ****             if (time > 0)
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 23


 777              		.loc 2 383 22
 778 005c 3B68     		ldr	r3, [r7]
 779              		.loc 2 383 16
 780 005e 002B     		cmp	r3, #0
 781 0060 0BDD     		ble	.L39
 384:./rt_thread/src/ipc.c ****             {
 385:./rt_thread/src/ipc.c ****                 RT_DEBUG_LOG(RT_DEBUG_IPC, ("set thread:%s to timer list\n",
 386:./rt_thread/src/ipc.c ****                                             thread->name));
 387:./rt_thread/src/ipc.c **** 
 388:./rt_thread/src/ipc.c ****                 /* reset the timeout of thread timer and start it */
 389:./rt_thread/src/ipc.c ****                 rt_timer_control(&(thread->thread_timer),
 782              		.loc 2 389 17
 783 0062 FB68     		ldr	r3, [r7, #12]
 784 0064 4433     		adds	r3, r3, #68
 785 0066 3A46     		mov	r2, r7
 786 0068 0021     		movs	r1, #0
 787 006a 1846     		mov	r0, r3
 788 006c FFF7FEFF 		bl	rt_timer_control
 390:./rt_thread/src/ipc.c ****                                  RT_TIMER_CTRL_SET_TIME,
 391:./rt_thread/src/ipc.c ****                                  &time);
 392:./rt_thread/src/ipc.c ****                 rt_timer_start(&(thread->thread_timer));
 789              		.loc 2 392 17
 790 0070 FB68     		ldr	r3, [r7, #12]
 791 0072 4433     		adds	r3, r3, #68
 792 0074 1846     		mov	r0, r3
 793 0076 FFF7FEFF 		bl	rt_timer_start
 794              	.L39:
 393:./rt_thread/src/ipc.c ****             }
 394:./rt_thread/src/ipc.c **** 
 395:./rt_thread/src/ipc.c ****             /* enable interrupt */
 396:./rt_thread/src/ipc.c ****             rt_hw_interrupt_enable(temp);
 795              		.loc 2 396 13
 796 007a 2046     		mov	r0, r4
 797 007c FFF7FEFF 		bl	rt_hw_interrupt_enable
 397:./rt_thread/src/ipc.c **** 
 398:./rt_thread/src/ipc.c ****             /* do schedule */
 399:./rt_thread/src/ipc.c ****             rt_schedule();
 798              		.loc 2 399 13
 799 0080 FFF7FEFF 		bl	rt_schedule
 400:./rt_thread/src/ipc.c **** 
 401:./rt_thread/src/ipc.c ****             if (thread->error != RT_EOK)
 800              		.loc 2 401 23
 801 0084 FB68     		ldr	r3, [r7, #12]
 802 0086 1B6B     		ldr	r3, [r3, #48]
 803              		.loc 2 401 16
 804 0088 002B     		cmp	r3, #0
 805 008a 02D0     		beq	.L36
 402:./rt_thread/src/ipc.c ****             {
 403:./rt_thread/src/ipc.c ****                 return thread->error;
 806              		.loc 2 403 30
 807 008c FB68     		ldr	r3, [r7, #12]
 808 008e 1B6B     		ldr	r3, [r3, #48]
 809 0090 00E0     		b	.L38
 810              	.L36:
 404:./rt_thread/src/ipc.c ****             }
 405:./rt_thread/src/ipc.c ****         }
 406:./rt_thread/src/ipc.c ****     }
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 24


 407:./rt_thread/src/ipc.c **** 
 408:./rt_thread/src/ipc.c ****     RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(sem->parent.parent)));
 409:./rt_thread/src/ipc.c **** 
 410:./rt_thread/src/ipc.c ****     return RT_EOK;
 811              		.loc 2 410 12
 812 0092 0023     		movs	r3, #0
 813              	.L38:
 411:./rt_thread/src/ipc.c **** }
 814              		.loc 2 411 1
 815 0094 1846     		mov	r0, r3
 816 0096 1437     		adds	r7, r7, #20
 817              	.LCFI61:
 818              		.cfi_def_cfa_offset 12
 819 0098 BD46     		mov	sp, r7
 820              	.LCFI62:
 821              		.cfi_def_cfa_register 13
 822              		@ sp needed
 823 009a 90BD     		pop	{r4, r7, pc}
 824              		.cfi_endproc
 825              	.LFE23:
 827              		.section	.text.rt_sem_trytake,"ax",%progbits
 828              		.align	1
 829              		.global	rt_sem_trytake
 830              		.syntax unified
 831              		.thumb
 832              		.thumb_func
 834              	rt_sem_trytake:
 835              	.LFB24:
 412:./rt_thread/src/ipc.c **** 
 413:./rt_thread/src/ipc.c **** /**
 414:./rt_thread/src/ipc.c ****  * This function will try to take a semaphore and immediately return
 415:./rt_thread/src/ipc.c ****  *
 416:./rt_thread/src/ipc.c ****  * @param sem the semaphore object
 417:./rt_thread/src/ipc.c ****  *
 418:./rt_thread/src/ipc.c ****  * @return the error code
 419:./rt_thread/src/ipc.c ****  */
 420:./rt_thread/src/ipc.c **** rt_err_t rt_sem_trytake(rt_sem_t sem)
 421:./rt_thread/src/ipc.c **** {
 836              		.loc 2 421 1
 837              		.cfi_startproc
 838              		@ args = 0, pretend = 0, frame = 8
 839              		@ frame_needed = 1, uses_anonymous_args = 0
 840 0000 80B5     		push	{r7, lr}
 841              	.LCFI63:
 842              		.cfi_def_cfa_offset 8
 843              		.cfi_offset 7, -8
 844              		.cfi_offset 14, -4
 845 0002 82B0     		sub	sp, sp, #8
 846              	.LCFI64:
 847              		.cfi_def_cfa_offset 16
 848 0004 00AF     		add	r7, sp, #0
 849              	.LCFI65:
 850              		.cfi_def_cfa_register 7
 851 0006 7860     		str	r0, [r7, #4]
 422:./rt_thread/src/ipc.c ****     return rt_sem_take(sem, 0);
 852              		.loc 2 422 12
 853 0008 0021     		movs	r1, #0
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 25


 854 000a 7868     		ldr	r0, [r7, #4]
 855 000c FFF7FEFF 		bl	rt_sem_take
 856 0010 0346     		mov	r3, r0
 423:./rt_thread/src/ipc.c **** }
 857              		.loc 2 423 1
 858 0012 1846     		mov	r0, r3
 859 0014 0837     		adds	r7, r7, #8
 860              	.LCFI66:
 861              		.cfi_def_cfa_offset 8
 862 0016 BD46     		mov	sp, r7
 863              	.LCFI67:
 864              		.cfi_def_cfa_register 13
 865              		@ sp needed
 866 0018 80BD     		pop	{r7, pc}
 867              		.cfi_endproc
 868              	.LFE24:
 870              		.section	.text.rt_sem_release,"ax",%progbits
 871              		.align	1
 872              		.global	rt_sem_release
 873              		.syntax unified
 874              		.thumb
 875              		.thumb_func
 877              	rt_sem_release:
 878              	.LFB25:
 424:./rt_thread/src/ipc.c **** 
 425:./rt_thread/src/ipc.c **** /**
 426:./rt_thread/src/ipc.c ****  * This function will release a semaphore, if there are threads suspended on
 427:./rt_thread/src/ipc.c ****  * semaphore, it will be waked up.
 428:./rt_thread/src/ipc.c ****  *
 429:./rt_thread/src/ipc.c ****  * @param sem the semaphore object
 430:./rt_thread/src/ipc.c ****  *
 431:./rt_thread/src/ipc.c ****  * @return the error code
 432:./rt_thread/src/ipc.c ****  */
 433:./rt_thread/src/ipc.c **** rt_err_t rt_sem_release(rt_sem_t sem)
 434:./rt_thread/src/ipc.c **** {
 879              		.loc 2 434 1
 880              		.cfi_startproc
 881              		@ args = 0, pretend = 0, frame = 8
 882              		@ frame_needed = 1, uses_anonymous_args = 0
 883 0000 B0B5     		push	{r4, r5, r7, lr}
 884              	.LCFI68:
 885              		.cfi_def_cfa_offset 16
 886              		.cfi_offset 4, -16
 887              		.cfi_offset 5, -12
 888              		.cfi_offset 7, -8
 889              		.cfi_offset 14, -4
 890 0002 82B0     		sub	sp, sp, #8
 891              	.LCFI69:
 892              		.cfi_def_cfa_offset 24
 893 0004 00AF     		add	r7, sp, #0
 894              	.LCFI70:
 895              		.cfi_def_cfa_register 7
 896 0006 7860     		str	r0, [r7, #4]
 435:./rt_thread/src/ipc.c ****     register rt_base_t temp;
 436:./rt_thread/src/ipc.c ****     register rt_bool_t need_schedule;
 437:./rt_thread/src/ipc.c **** 
 438:./rt_thread/src/ipc.c ****     /* parameter check */
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 26


 439:./rt_thread/src/ipc.c ****     RT_ASSERT(sem != RT_NULL);
 440:./rt_thread/src/ipc.c ****     RT_ASSERT(rt_object_get_type(&sem->parent.parent) == RT_Object_Class_Semaphore);
 441:./rt_thread/src/ipc.c **** 
 442:./rt_thread/src/ipc.c ****     RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(sem->parent.parent)));
 443:./rt_thread/src/ipc.c **** 
 444:./rt_thread/src/ipc.c ****     need_schedule = RT_FALSE;
 897              		.loc 2 444 19
 898 0008 0025     		movs	r5, #0
 445:./rt_thread/src/ipc.c **** 
 446:./rt_thread/src/ipc.c ****     /* disable interrupt */
 447:./rt_thread/src/ipc.c ****     temp = rt_hw_interrupt_disable();
 899              		.loc 2 447 12
 900 000a FFF7FEFF 		bl	rt_hw_interrupt_disable
 901 000e 0446     		mov	r4, r0
 448:./rt_thread/src/ipc.c **** 
 449:./rt_thread/src/ipc.c ****     RT_DEBUG_LOG(RT_DEBUG_IPC, ("thread %s releases sem:%s, which value is: %d\n",
 450:./rt_thread/src/ipc.c ****                                 rt_thread_self()->name,
 451:./rt_thread/src/ipc.c ****                                 ((struct rt_object *)sem)->name,
 452:./rt_thread/src/ipc.c ****                                 sem->value));
 453:./rt_thread/src/ipc.c **** 
 454:./rt_thread/src/ipc.c ****     if (!rt_list_isempty(&sem->parent.suspend_thread))
 902              		.loc 2 454 26
 903 0010 7B68     		ldr	r3, [r7, #4]
 904 0012 1433     		adds	r3, r3, #20
 905              		.loc 2 454 10
 906 0014 1846     		mov	r0, r3
 907 0016 FFF7FEFF 		bl	rt_list_isempty
 908 001a 0346     		mov	r3, r0
 909              		.loc 2 454 8
 910 001c 002B     		cmp	r3, #0
 911 001e 06D1     		bne	.L43
 455:./rt_thread/src/ipc.c ****     {
 456:./rt_thread/src/ipc.c ****         /* resume the suspended thread */
 457:./rt_thread/src/ipc.c ****         rt_ipc_list_resume(&(sem->parent.suspend_thread));
 912              		.loc 2 457 9
 913 0020 7B68     		ldr	r3, [r7, #4]
 914 0022 1433     		adds	r3, r3, #20
 915 0024 1846     		mov	r0, r3
 916 0026 FFF7FEFF 		bl	rt_ipc_list_resume
 458:./rt_thread/src/ipc.c ****         need_schedule = RT_TRUE;
 917              		.loc 2 458 23
 918 002a 0125     		movs	r5, #1
 919 002c 12E0     		b	.L44
 920              	.L43:
 459:./rt_thread/src/ipc.c ****     }
 460:./rt_thread/src/ipc.c ****     else
 461:./rt_thread/src/ipc.c ****     {
 462:./rt_thread/src/ipc.c ****         if(sem->value < RT_SEM_VALUE_MAX)
 921              		.loc 2 462 15
 922 002e 7B68     		ldr	r3, [r7, #4]
 923 0030 9B8B     		ldrh	r3, [r3, #28]
 924              		.loc 2 462 11
 925 0032 4FF6FF72 		movw	r2, #65535
 926 0036 9342     		cmp	r3, r2
 927 0038 06D0     		beq	.L45
 463:./rt_thread/src/ipc.c ****         {
 464:./rt_thread/src/ipc.c ****             sem->value ++; /* increase value */
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 27


 928              		.loc 2 464 16
 929 003a 7B68     		ldr	r3, [r7, #4]
 930 003c 9B8B     		ldrh	r3, [r3, #28]
 931              		.loc 2 464 24
 932 003e 0133     		adds	r3, r3, #1
 933 0040 9AB2     		uxth	r2, r3
 934 0042 7B68     		ldr	r3, [r7, #4]
 935 0044 9A83     		strh	r2, [r3, #28]	@ movhi
 936 0046 05E0     		b	.L44
 937              	.L45:
 465:./rt_thread/src/ipc.c ****         }
 466:./rt_thread/src/ipc.c ****         else
 467:./rt_thread/src/ipc.c ****         {
 468:./rt_thread/src/ipc.c ****             rt_hw_interrupt_enable(temp); /* enable interrupt */
 938              		.loc 2 468 13
 939 0048 2046     		mov	r0, r4
 940 004a FFF7FEFF 		bl	rt_hw_interrupt_enable
 469:./rt_thread/src/ipc.c ****             return -RT_EFULL; /* value overflowed */
 941              		.loc 2 469 20
 942 004e 6FF00203 		mvn	r3, #2
 943 0052 07E0     		b	.L46
 944              	.L44:
 470:./rt_thread/src/ipc.c ****         }
 471:./rt_thread/src/ipc.c ****     }
 472:./rt_thread/src/ipc.c **** 
 473:./rt_thread/src/ipc.c ****     /* enable interrupt */
 474:./rt_thread/src/ipc.c ****     rt_hw_interrupt_enable(temp);
 945              		.loc 2 474 5
 946 0054 2046     		mov	r0, r4
 947 0056 FFF7FEFF 		bl	rt_hw_interrupt_enable
 475:./rt_thread/src/ipc.c **** 
 476:./rt_thread/src/ipc.c ****     /* resume a thread, re-schedule */
 477:./rt_thread/src/ipc.c ****     if (need_schedule == RT_TRUE)
 948              		.loc 2 477 8
 949 005a 012D     		cmp	r5, #1
 950 005c 01D1     		bne	.L47
 478:./rt_thread/src/ipc.c ****         rt_schedule();
 951              		.loc 2 478 9
 952 005e FFF7FEFF 		bl	rt_schedule
 953              	.L47:
 479:./rt_thread/src/ipc.c **** 
 480:./rt_thread/src/ipc.c ****     return RT_EOK;
 954              		.loc 2 480 12
 955 0062 0023     		movs	r3, #0
 956              	.L46:
 481:./rt_thread/src/ipc.c **** }
 957              		.loc 2 481 1
 958 0064 1846     		mov	r0, r3
 959 0066 0837     		adds	r7, r7, #8
 960              	.LCFI71:
 961              		.cfi_def_cfa_offset 16
 962 0068 BD46     		mov	sp, r7
 963              	.LCFI72:
 964              		.cfi_def_cfa_register 13
 965              		@ sp needed
 966 006a B0BD     		pop	{r4, r5, r7, pc}
 967              		.cfi_endproc
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 28


 968              	.LFE25:
 970              		.section	.text.rt_sem_control,"ax",%progbits
 971              		.align	1
 972              		.global	rt_sem_control
 973              		.syntax unified
 974              		.thumb
 975              		.thumb_func
 977              	rt_sem_control:
 978              	.LFB26:
 482:./rt_thread/src/ipc.c **** 
 483:./rt_thread/src/ipc.c **** /**
 484:./rt_thread/src/ipc.c ****  * This function can get or set some extra attributions of a semaphore object.
 485:./rt_thread/src/ipc.c ****  *
 486:./rt_thread/src/ipc.c ****  * @param sem the semaphore object
 487:./rt_thread/src/ipc.c ****  * @param cmd the execution command
 488:./rt_thread/src/ipc.c ****  * @param arg the execution argument
 489:./rt_thread/src/ipc.c ****  *
 490:./rt_thread/src/ipc.c ****  * @return the error code
 491:./rt_thread/src/ipc.c ****  */
 492:./rt_thread/src/ipc.c **** rt_err_t rt_sem_control(rt_sem_t sem, int cmd, void *arg)
 493:./rt_thread/src/ipc.c **** {
 979              		.loc 2 493 1
 980              		.cfi_startproc
 981              		@ args = 0, pretend = 0, frame = 24
 982              		@ frame_needed = 1, uses_anonymous_args = 0
 983 0000 80B5     		push	{r7, lr}
 984              	.LCFI73:
 985              		.cfi_def_cfa_offset 8
 986              		.cfi_offset 7, -8
 987              		.cfi_offset 14, -4
 988 0002 86B0     		sub	sp, sp, #24
 989              	.LCFI74:
 990              		.cfi_def_cfa_offset 32
 991 0004 00AF     		add	r7, sp, #0
 992              	.LCFI75:
 993              		.cfi_def_cfa_register 7
 994 0006 F860     		str	r0, [r7, #12]
 995 0008 B960     		str	r1, [r7, #8]
 996 000a 7A60     		str	r2, [r7, #4]
 494:./rt_thread/src/ipc.c ****     rt_ubase_t level;
 495:./rt_thread/src/ipc.c **** 
 496:./rt_thread/src/ipc.c ****     /* parameter check */
 497:./rt_thread/src/ipc.c ****     RT_ASSERT(sem != RT_NULL);
 498:./rt_thread/src/ipc.c ****     RT_ASSERT(rt_object_get_type(&sem->parent.parent) == RT_Object_Class_Semaphore);
 499:./rt_thread/src/ipc.c **** 
 500:./rt_thread/src/ipc.c ****     if (cmd == RT_IPC_CMD_RESET)
 997              		.loc 2 500 8
 998 000c BB68     		ldr	r3, [r7, #8]
 999 000e 012B     		cmp	r3, #1
 1000 0010 16D1     		bne	.L49
 1001              	.LBB3:
 501:./rt_thread/src/ipc.c ****     {
 502:./rt_thread/src/ipc.c ****         rt_ubase_t value;
 503:./rt_thread/src/ipc.c **** 
 504:./rt_thread/src/ipc.c ****         /* get value */
 505:./rt_thread/src/ipc.c ****         value = (rt_ubase_t)arg;
 1002              		.loc 2 505 15
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 29


 1003 0012 7B68     		ldr	r3, [r7, #4]
 1004 0014 7B61     		str	r3, [r7, #20]
 506:./rt_thread/src/ipc.c ****         /* disable interrupt */
 507:./rt_thread/src/ipc.c ****         level = rt_hw_interrupt_disable();
 1005              		.loc 2 507 17
 1006 0016 FFF7FEFF 		bl	rt_hw_interrupt_disable
 1007 001a 0346     		mov	r3, r0
 1008              		.loc 2 507 15
 1009 001c 3B61     		str	r3, [r7, #16]
 508:./rt_thread/src/ipc.c **** 
 509:./rt_thread/src/ipc.c ****         /* resume all waiting thread */
 510:./rt_thread/src/ipc.c ****         rt_ipc_list_resume_all(&sem->parent.suspend_thread);
 1010              		.loc 2 510 9
 1011 001e FB68     		ldr	r3, [r7, #12]
 1012 0020 1433     		adds	r3, r3, #20
 1013 0022 1846     		mov	r0, r3
 1014 0024 FFF7FEFF 		bl	rt_ipc_list_resume_all
 511:./rt_thread/src/ipc.c **** 
 512:./rt_thread/src/ipc.c ****         /* set new value */
 513:./rt_thread/src/ipc.c ****         sem->value = (rt_uint16_t)value;
 1015              		.loc 2 513 22
 1016 0028 7B69     		ldr	r3, [r7, #20]
 1017 002a 9AB2     		uxth	r2, r3
 1018              		.loc 2 513 20
 1019 002c FB68     		ldr	r3, [r7, #12]
 1020 002e 9A83     		strh	r2, [r3, #28]	@ movhi
 514:./rt_thread/src/ipc.c **** 
 515:./rt_thread/src/ipc.c ****         /* enable interrupt */
 516:./rt_thread/src/ipc.c ****         rt_hw_interrupt_enable(level);
 1021              		.loc 2 516 9
 1022 0030 3B69     		ldr	r3, [r7, #16]
 1023 0032 1846     		mov	r0, r3
 1024 0034 FFF7FEFF 		bl	rt_hw_interrupt_enable
 517:./rt_thread/src/ipc.c **** 
 518:./rt_thread/src/ipc.c ****         rt_schedule();
 1025              		.loc 2 518 9
 1026 0038 FFF7FEFF 		bl	rt_schedule
 519:./rt_thread/src/ipc.c **** 
 520:./rt_thread/src/ipc.c ****         return RT_EOK;
 1027              		.loc 2 520 16
 1028 003c 0023     		movs	r3, #0
 1029 003e 01E0     		b	.L50
 1030              	.L49:
 1031              	.LBE3:
 521:./rt_thread/src/ipc.c ****     }
 522:./rt_thread/src/ipc.c **** 
 523:./rt_thread/src/ipc.c ****     return -RT_ERROR;
 1032              		.loc 2 523 12
 1033 0040 4FF0FF33 		mov	r3, #-1
 1034              	.L50:
 524:./rt_thread/src/ipc.c **** }
 1035              		.loc 2 524 1
 1036 0044 1846     		mov	r0, r3
 1037 0046 1837     		adds	r7, r7, #24
 1038              	.LCFI76:
 1039              		.cfi_def_cfa_offset 8
 1040 0048 BD46     		mov	sp, r7
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 30


 1041              	.LCFI77:
 1042              		.cfi_def_cfa_register 13
 1043              		@ sp needed
 1044 004a 80BD     		pop	{r7, pc}
 1045              		.cfi_endproc
 1046              	.LFE26:
 1048              		.section	.text.rt_mb_init,"ax",%progbits
 1049              		.align	1
 1050              		.global	rt_mb_init
 1051              		.syntax unified
 1052              		.thumb
 1053              		.thumb_func
 1055              	rt_mb_init:
 1056              	.LFB27:
 525:./rt_thread/src/ipc.c **** #endif /* end of RT_USING_SEMAPHORE */
 526:./rt_thread/src/ipc.c **** 
 527:./rt_thread/src/ipc.c **** #ifdef RT_USING_MUTEX
 528:./rt_thread/src/ipc.c **** /**
 529:./rt_thread/src/ipc.c ****  * This function will initialize a mutex and put it under control of resource
 530:./rt_thread/src/ipc.c ****  * management.
 531:./rt_thread/src/ipc.c ****  *
 532:./rt_thread/src/ipc.c ****  * @param mutex the mutex object
 533:./rt_thread/src/ipc.c ****  * @param name the name of mutex
 534:./rt_thread/src/ipc.c ****  * @param flag the flag of mutex
 535:./rt_thread/src/ipc.c ****  *
 536:./rt_thread/src/ipc.c ****  * @return the operation status, RT_EOK on successful
 537:./rt_thread/src/ipc.c ****  */
 538:./rt_thread/src/ipc.c **** rt_err_t rt_mutex_init(rt_mutex_t mutex, const char *name, rt_uint8_t flag)
 539:./rt_thread/src/ipc.c **** {
 540:./rt_thread/src/ipc.c ****     /* parameter check */
 541:./rt_thread/src/ipc.c ****     RT_ASSERT(mutex != RT_NULL);
 542:./rt_thread/src/ipc.c **** 
 543:./rt_thread/src/ipc.c ****     /* initialize object */
 544:./rt_thread/src/ipc.c ****     rt_object_init(&(mutex->parent.parent), RT_Object_Class_Mutex, name);
 545:./rt_thread/src/ipc.c **** 
 546:./rt_thread/src/ipc.c ****     /* initialize ipc object */
 547:./rt_thread/src/ipc.c ****     rt_ipc_object_init(&(mutex->parent));
 548:./rt_thread/src/ipc.c **** 
 549:./rt_thread/src/ipc.c ****     mutex->value = 1;
 550:./rt_thread/src/ipc.c ****     mutex->owner = RT_NULL;
 551:./rt_thread/src/ipc.c ****     mutex->original_priority = 0xFF;
 552:./rt_thread/src/ipc.c ****     mutex->hold  = 0;
 553:./rt_thread/src/ipc.c **** 
 554:./rt_thread/src/ipc.c ****     /* set flag */
 555:./rt_thread/src/ipc.c ****     mutex->parent.parent.flag = flag;
 556:./rt_thread/src/ipc.c **** 
 557:./rt_thread/src/ipc.c ****     return RT_EOK;
 558:./rt_thread/src/ipc.c **** }
 559:./rt_thread/src/ipc.c **** 
 560:./rt_thread/src/ipc.c **** /**
 561:./rt_thread/src/ipc.c ****  * This function will detach a mutex from resource management
 562:./rt_thread/src/ipc.c ****  *
 563:./rt_thread/src/ipc.c ****  * @param mutex the mutex object
 564:./rt_thread/src/ipc.c ****  *
 565:./rt_thread/src/ipc.c ****  * @return the operation status, RT_EOK on successful
 566:./rt_thread/src/ipc.c ****  *
 567:./rt_thread/src/ipc.c ****  * @see rt_mutex_delete
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 31


 568:./rt_thread/src/ipc.c ****  */
 569:./rt_thread/src/ipc.c **** rt_err_t rt_mutex_detach(rt_mutex_t mutex)
 570:./rt_thread/src/ipc.c **** {
 571:./rt_thread/src/ipc.c ****     /* parameter check */
 572:./rt_thread/src/ipc.c ****     RT_ASSERT(mutex != RT_NULL);
 573:./rt_thread/src/ipc.c ****     RT_ASSERT(rt_object_get_type(&mutex->parent.parent) == RT_Object_Class_Mutex);
 574:./rt_thread/src/ipc.c ****     RT_ASSERT(rt_object_is_systemobject(&mutex->parent.parent));
 575:./rt_thread/src/ipc.c **** 
 576:./rt_thread/src/ipc.c ****     /* wakeup all suspended threads */
 577:./rt_thread/src/ipc.c ****     rt_ipc_list_resume_all(&(mutex->parent.suspend_thread));
 578:./rt_thread/src/ipc.c **** 
 579:./rt_thread/src/ipc.c ****     /* detach semaphore object */
 580:./rt_thread/src/ipc.c ****     rt_object_detach(&(mutex->parent.parent));
 581:./rt_thread/src/ipc.c **** 
 582:./rt_thread/src/ipc.c ****     return RT_EOK;
 583:./rt_thread/src/ipc.c **** }
 584:./rt_thread/src/ipc.c **** 
 585:./rt_thread/src/ipc.c **** #ifdef RT_USING_HEAP
 586:./rt_thread/src/ipc.c **** /**
 587:./rt_thread/src/ipc.c ****  * This function will create a mutex from system resource
 588:./rt_thread/src/ipc.c ****  *
 589:./rt_thread/src/ipc.c ****  * @param name the name of mutex
 590:./rt_thread/src/ipc.c ****  * @param flag the flag of mutex
 591:./rt_thread/src/ipc.c ****  *
 592:./rt_thread/src/ipc.c ****  * @return the created mutex, RT_NULL on error happen
 593:./rt_thread/src/ipc.c ****  *
 594:./rt_thread/src/ipc.c ****  * @see rt_mutex_init
 595:./rt_thread/src/ipc.c ****  */
 596:./rt_thread/src/ipc.c **** rt_mutex_t rt_mutex_create(const char *name, rt_uint8_t flag)
 597:./rt_thread/src/ipc.c **** {
 598:./rt_thread/src/ipc.c ****     struct rt_mutex *mutex;
 599:./rt_thread/src/ipc.c **** 
 600:./rt_thread/src/ipc.c ****     RT_DEBUG_NOT_IN_INTERRUPT;
 601:./rt_thread/src/ipc.c **** 
 602:./rt_thread/src/ipc.c ****     /* allocate object */
 603:./rt_thread/src/ipc.c ****     mutex = (rt_mutex_t)rt_object_allocate(RT_Object_Class_Mutex, name);
 604:./rt_thread/src/ipc.c ****     if (mutex == RT_NULL)
 605:./rt_thread/src/ipc.c ****         return mutex;
 606:./rt_thread/src/ipc.c **** 
 607:./rt_thread/src/ipc.c ****     /* initialize ipc object */
 608:./rt_thread/src/ipc.c ****     rt_ipc_object_init(&(mutex->parent));
 609:./rt_thread/src/ipc.c **** 
 610:./rt_thread/src/ipc.c ****     mutex->value              = 1;
 611:./rt_thread/src/ipc.c ****     mutex->owner              = RT_NULL;
 612:./rt_thread/src/ipc.c ****     mutex->original_priority  = 0xFF;
 613:./rt_thread/src/ipc.c ****     mutex->hold               = 0;
 614:./rt_thread/src/ipc.c **** 
 615:./rt_thread/src/ipc.c ****     /* set flag */
 616:./rt_thread/src/ipc.c ****     mutex->parent.parent.flag = flag;
 617:./rt_thread/src/ipc.c **** 
 618:./rt_thread/src/ipc.c ****     return mutex;
 619:./rt_thread/src/ipc.c **** }
 620:./rt_thread/src/ipc.c **** 
 621:./rt_thread/src/ipc.c **** /**
 622:./rt_thread/src/ipc.c ****  * This function will delete a mutex object and release the memory
 623:./rt_thread/src/ipc.c ****  *
 624:./rt_thread/src/ipc.c ****  * @param mutex the mutex object
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 32


 625:./rt_thread/src/ipc.c ****  *
 626:./rt_thread/src/ipc.c ****  * @return the error code
 627:./rt_thread/src/ipc.c ****  *
 628:./rt_thread/src/ipc.c ****  * @see rt_mutex_detach
 629:./rt_thread/src/ipc.c ****  */
 630:./rt_thread/src/ipc.c **** rt_err_t rt_mutex_delete(rt_mutex_t mutex)
 631:./rt_thread/src/ipc.c **** {
 632:./rt_thread/src/ipc.c ****     RT_DEBUG_NOT_IN_INTERRUPT;
 633:./rt_thread/src/ipc.c **** 
 634:./rt_thread/src/ipc.c ****     /* parameter check */
 635:./rt_thread/src/ipc.c ****     RT_ASSERT(mutex != RT_NULL);
 636:./rt_thread/src/ipc.c ****     RT_ASSERT(rt_object_get_type(&mutex->parent.parent) == RT_Object_Class_Mutex);
 637:./rt_thread/src/ipc.c ****     RT_ASSERT(rt_object_is_systemobject(&mutex->parent.parent) == RT_FALSE);
 638:./rt_thread/src/ipc.c **** 
 639:./rt_thread/src/ipc.c ****     /* wakeup all suspended threads */
 640:./rt_thread/src/ipc.c ****     rt_ipc_list_resume_all(&(mutex->parent.suspend_thread));
 641:./rt_thread/src/ipc.c **** 
 642:./rt_thread/src/ipc.c ****     /* delete mutex object */
 643:./rt_thread/src/ipc.c ****     rt_object_delete(&(mutex->parent.parent));
 644:./rt_thread/src/ipc.c **** 
 645:./rt_thread/src/ipc.c ****     return RT_EOK;
 646:./rt_thread/src/ipc.c **** }
 647:./rt_thread/src/ipc.c **** #endif
 648:./rt_thread/src/ipc.c **** 
 649:./rt_thread/src/ipc.c **** /**
 650:./rt_thread/src/ipc.c ****  * This function will take a mutex, if the mutex is unavailable, the
 651:./rt_thread/src/ipc.c ****  * thread shall wait for a specified time.
 652:./rt_thread/src/ipc.c ****  *
 653:./rt_thread/src/ipc.c ****  * @param mutex the mutex object
 654:./rt_thread/src/ipc.c ****  * @param time the waiting time
 655:./rt_thread/src/ipc.c ****  *
 656:./rt_thread/src/ipc.c ****  * @return the error code
 657:./rt_thread/src/ipc.c ****  */
 658:./rt_thread/src/ipc.c **** rt_err_t rt_mutex_take(rt_mutex_t mutex, rt_int32_t time)
 659:./rt_thread/src/ipc.c **** {
 660:./rt_thread/src/ipc.c ****     register rt_base_t temp;
 661:./rt_thread/src/ipc.c ****     struct rt_thread *thread;
 662:./rt_thread/src/ipc.c **** 
 663:./rt_thread/src/ipc.c ****     /* this function must not be used in interrupt even if time = 0 */
 664:./rt_thread/src/ipc.c ****     RT_DEBUG_IN_THREAD_CONTEXT;
 665:./rt_thread/src/ipc.c **** 
 666:./rt_thread/src/ipc.c ****     /* parameter check */
 667:./rt_thread/src/ipc.c ****     RT_ASSERT(mutex != RT_NULL);
 668:./rt_thread/src/ipc.c ****     RT_ASSERT(rt_object_get_type(&mutex->parent.parent) == RT_Object_Class_Mutex);
 669:./rt_thread/src/ipc.c **** 
 670:./rt_thread/src/ipc.c ****     /* get current thread */
 671:./rt_thread/src/ipc.c ****     thread = rt_thread_self();
 672:./rt_thread/src/ipc.c **** 
 673:./rt_thread/src/ipc.c ****     /* disable interrupt */
 674:./rt_thread/src/ipc.c ****     temp = rt_hw_interrupt_disable();
 675:./rt_thread/src/ipc.c **** 
 676:./rt_thread/src/ipc.c ****     RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(mutex->parent.parent)));
 677:./rt_thread/src/ipc.c **** 
 678:./rt_thread/src/ipc.c ****     RT_DEBUG_LOG(RT_DEBUG_IPC,
 679:./rt_thread/src/ipc.c ****                  ("mutex_take: current thread %s, mutex value: %d, hold: %d\n",
 680:./rt_thread/src/ipc.c ****                   thread->name, mutex->value, mutex->hold));
 681:./rt_thread/src/ipc.c **** 
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 33


 682:./rt_thread/src/ipc.c ****     /* reset thread error */
 683:./rt_thread/src/ipc.c ****     thread->error = RT_EOK;
 684:./rt_thread/src/ipc.c **** 
 685:./rt_thread/src/ipc.c ****     if (mutex->owner == thread)
 686:./rt_thread/src/ipc.c ****     {
 687:./rt_thread/src/ipc.c ****         if(mutex->hold < RT_MUTEX_HOLD_MAX)
 688:./rt_thread/src/ipc.c ****         {
 689:./rt_thread/src/ipc.c ****             /* it's the same thread */
 690:./rt_thread/src/ipc.c ****             mutex->hold ++;
 691:./rt_thread/src/ipc.c ****         }
 692:./rt_thread/src/ipc.c ****         else
 693:./rt_thread/src/ipc.c ****         {
 694:./rt_thread/src/ipc.c ****             rt_hw_interrupt_enable(temp); /* enable interrupt */
 695:./rt_thread/src/ipc.c ****             return -RT_EFULL; /* value overflowed */
 696:./rt_thread/src/ipc.c ****         }
 697:./rt_thread/src/ipc.c ****     }
 698:./rt_thread/src/ipc.c ****     else
 699:./rt_thread/src/ipc.c ****     {
 700:./rt_thread/src/ipc.c ****         /* The value of mutex is 1 in initial status. Therefore, if the
 701:./rt_thread/src/ipc.c ****          * value is great than 0, it indicates the mutex is avaible.
 702:./rt_thread/src/ipc.c ****          */
 703:./rt_thread/src/ipc.c ****         if (mutex->value > 0)
 704:./rt_thread/src/ipc.c ****         {
 705:./rt_thread/src/ipc.c ****             /* mutex is available */
 706:./rt_thread/src/ipc.c ****             mutex->value --;
 707:./rt_thread/src/ipc.c **** 
 708:./rt_thread/src/ipc.c ****             /* set mutex owner and original priority */
 709:./rt_thread/src/ipc.c ****             mutex->owner             = thread;
 710:./rt_thread/src/ipc.c ****             mutex->original_priority = thread->current_priority;
 711:./rt_thread/src/ipc.c ****             if(mutex->hold < RT_MUTEX_HOLD_MAX)
 712:./rt_thread/src/ipc.c ****             {
 713:./rt_thread/src/ipc.c ****                 mutex->hold ++;
 714:./rt_thread/src/ipc.c ****             }
 715:./rt_thread/src/ipc.c ****             else
 716:./rt_thread/src/ipc.c ****             {
 717:./rt_thread/src/ipc.c ****                 rt_hw_interrupt_enable(temp); /* enable interrupt */
 718:./rt_thread/src/ipc.c ****                 return -RT_EFULL; /* value overflowed */
 719:./rt_thread/src/ipc.c ****             }
 720:./rt_thread/src/ipc.c ****         }
 721:./rt_thread/src/ipc.c ****         else
 722:./rt_thread/src/ipc.c ****         {
 723:./rt_thread/src/ipc.c ****             /* no waiting, return with timeout */
 724:./rt_thread/src/ipc.c ****             if (time == 0)
 725:./rt_thread/src/ipc.c ****             {
 726:./rt_thread/src/ipc.c ****                 /* set error as timeout */
 727:./rt_thread/src/ipc.c ****                 thread->error = -RT_ETIMEOUT;
 728:./rt_thread/src/ipc.c **** 
 729:./rt_thread/src/ipc.c ****                 /* enable interrupt */
 730:./rt_thread/src/ipc.c ****                 rt_hw_interrupt_enable(temp);
 731:./rt_thread/src/ipc.c **** 
 732:./rt_thread/src/ipc.c ****                 return -RT_ETIMEOUT;
 733:./rt_thread/src/ipc.c ****             }
 734:./rt_thread/src/ipc.c ****             else
 735:./rt_thread/src/ipc.c ****             {
 736:./rt_thread/src/ipc.c ****                 /* mutex is unavailable, push to suspend list */
 737:./rt_thread/src/ipc.c ****                 RT_DEBUG_LOG(RT_DEBUG_IPC, ("mutex_take: suspend thread: %s\n",
 738:./rt_thread/src/ipc.c ****                                             thread->name));
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 34


 739:./rt_thread/src/ipc.c **** 
 740:./rt_thread/src/ipc.c ****                 /* change the owner thread priority of mutex */
 741:./rt_thread/src/ipc.c ****                 if (thread->current_priority < mutex->owner->current_priority)
 742:./rt_thread/src/ipc.c ****                 {
 743:./rt_thread/src/ipc.c ****                     /* change the owner thread priority */
 744:./rt_thread/src/ipc.c ****                     rt_thread_control(mutex->owner,
 745:./rt_thread/src/ipc.c ****                                       RT_THREAD_CTRL_CHANGE_PRIORITY,
 746:./rt_thread/src/ipc.c ****                                       &thread->current_priority);
 747:./rt_thread/src/ipc.c ****                 }
 748:./rt_thread/src/ipc.c **** 
 749:./rt_thread/src/ipc.c ****                 /* suspend current thread */
 750:./rt_thread/src/ipc.c ****                 rt_ipc_list_suspend(&(mutex->parent.suspend_thread),
 751:./rt_thread/src/ipc.c ****                                     thread,
 752:./rt_thread/src/ipc.c ****                                     mutex->parent.parent.flag);
 753:./rt_thread/src/ipc.c **** 
 754:./rt_thread/src/ipc.c ****                 /* has waiting time, start thread timer */
 755:./rt_thread/src/ipc.c ****                 if (time > 0)
 756:./rt_thread/src/ipc.c ****                 {
 757:./rt_thread/src/ipc.c ****                     RT_DEBUG_LOG(RT_DEBUG_IPC,
 758:./rt_thread/src/ipc.c ****                                  ("mutex_take: start the timer of thread:%s\n",
 759:./rt_thread/src/ipc.c ****                                   thread->name));
 760:./rt_thread/src/ipc.c **** 
 761:./rt_thread/src/ipc.c ****                     /* reset the timeout of thread timer and start it */
 762:./rt_thread/src/ipc.c ****                     rt_timer_control(&(thread->thread_timer),
 763:./rt_thread/src/ipc.c ****                                      RT_TIMER_CTRL_SET_TIME,
 764:./rt_thread/src/ipc.c ****                                      &time);
 765:./rt_thread/src/ipc.c ****                     rt_timer_start(&(thread->thread_timer));
 766:./rt_thread/src/ipc.c ****                 }
 767:./rt_thread/src/ipc.c **** 
 768:./rt_thread/src/ipc.c ****                 /* enable interrupt */
 769:./rt_thread/src/ipc.c ****                 rt_hw_interrupt_enable(temp);
 770:./rt_thread/src/ipc.c **** 
 771:./rt_thread/src/ipc.c ****                 /* do schedule */
 772:./rt_thread/src/ipc.c ****                 rt_schedule();
 773:./rt_thread/src/ipc.c **** 
 774:./rt_thread/src/ipc.c ****                 if (thread->error != RT_EOK)
 775:./rt_thread/src/ipc.c ****                 {
 776:./rt_thread/src/ipc.c ****                     /* return error */
 777:./rt_thread/src/ipc.c ****                     return thread->error;
 778:./rt_thread/src/ipc.c ****                 }
 779:./rt_thread/src/ipc.c ****                 else
 780:./rt_thread/src/ipc.c ****                 {
 781:./rt_thread/src/ipc.c ****                     /* the mutex is taken successfully. */
 782:./rt_thread/src/ipc.c ****                     /* disable interrupt */
 783:./rt_thread/src/ipc.c ****                     temp = rt_hw_interrupt_disable();
 784:./rt_thread/src/ipc.c ****                 }
 785:./rt_thread/src/ipc.c ****             }
 786:./rt_thread/src/ipc.c ****         }
 787:./rt_thread/src/ipc.c ****     }
 788:./rt_thread/src/ipc.c **** 
 789:./rt_thread/src/ipc.c ****     /* enable interrupt */
 790:./rt_thread/src/ipc.c ****     rt_hw_interrupt_enable(temp);
 791:./rt_thread/src/ipc.c **** 
 792:./rt_thread/src/ipc.c ****     RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(mutex->parent.parent)));
 793:./rt_thread/src/ipc.c **** 
 794:./rt_thread/src/ipc.c ****     return RT_EOK;
 795:./rt_thread/src/ipc.c **** }
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 35


 796:./rt_thread/src/ipc.c **** 
 797:./rt_thread/src/ipc.c **** /**
 798:./rt_thread/src/ipc.c ****  * This function will release a mutex, if there are threads suspended on mutex,
 799:./rt_thread/src/ipc.c ****  * it will be waked up.
 800:./rt_thread/src/ipc.c ****  *
 801:./rt_thread/src/ipc.c ****  * @param mutex the mutex object
 802:./rt_thread/src/ipc.c ****  *
 803:./rt_thread/src/ipc.c ****  * @return the error code
 804:./rt_thread/src/ipc.c ****  */
 805:./rt_thread/src/ipc.c **** rt_err_t rt_mutex_release(rt_mutex_t mutex)
 806:./rt_thread/src/ipc.c **** {
 807:./rt_thread/src/ipc.c ****     register rt_base_t temp;
 808:./rt_thread/src/ipc.c ****     struct rt_thread *thread;
 809:./rt_thread/src/ipc.c ****     rt_bool_t need_schedule;
 810:./rt_thread/src/ipc.c **** 
 811:./rt_thread/src/ipc.c ****     /* parameter check */
 812:./rt_thread/src/ipc.c ****     RT_ASSERT(mutex != RT_NULL);
 813:./rt_thread/src/ipc.c ****     RT_ASSERT(rt_object_get_type(&mutex->parent.parent) == RT_Object_Class_Mutex);
 814:./rt_thread/src/ipc.c **** 
 815:./rt_thread/src/ipc.c ****     need_schedule = RT_FALSE;
 816:./rt_thread/src/ipc.c **** 
 817:./rt_thread/src/ipc.c ****     /* only thread could release mutex because we need test the ownership */
 818:./rt_thread/src/ipc.c ****     RT_DEBUG_IN_THREAD_CONTEXT;
 819:./rt_thread/src/ipc.c **** 
 820:./rt_thread/src/ipc.c ****     /* get current thread */
 821:./rt_thread/src/ipc.c ****     thread = rt_thread_self();
 822:./rt_thread/src/ipc.c **** 
 823:./rt_thread/src/ipc.c ****     /* disable interrupt */
 824:./rt_thread/src/ipc.c ****     temp = rt_hw_interrupt_disable();
 825:./rt_thread/src/ipc.c **** 
 826:./rt_thread/src/ipc.c ****     RT_DEBUG_LOG(RT_DEBUG_IPC,
 827:./rt_thread/src/ipc.c ****                  ("mutex_release:current thread %s, mutex value: %d, hold: %d\n",
 828:./rt_thread/src/ipc.c ****                   thread->name, mutex->value, mutex->hold));
 829:./rt_thread/src/ipc.c **** 
 830:./rt_thread/src/ipc.c ****     RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(mutex->parent.parent)));
 831:./rt_thread/src/ipc.c **** 
 832:./rt_thread/src/ipc.c ****     /* mutex only can be released by owner */
 833:./rt_thread/src/ipc.c ****     if (thread != mutex->owner)
 834:./rt_thread/src/ipc.c ****     {
 835:./rt_thread/src/ipc.c ****         thread->error = -RT_ERROR;
 836:./rt_thread/src/ipc.c **** 
 837:./rt_thread/src/ipc.c ****         /* enable interrupt */
 838:./rt_thread/src/ipc.c ****         rt_hw_interrupt_enable(temp);
 839:./rt_thread/src/ipc.c **** 
 840:./rt_thread/src/ipc.c ****         return -RT_ERROR;
 841:./rt_thread/src/ipc.c ****     }
 842:./rt_thread/src/ipc.c **** 
 843:./rt_thread/src/ipc.c ****     /* decrease hold */
 844:./rt_thread/src/ipc.c ****     mutex->hold --;
 845:./rt_thread/src/ipc.c ****     /* if no hold */
 846:./rt_thread/src/ipc.c ****     if (mutex->hold == 0)
 847:./rt_thread/src/ipc.c ****     {
 848:./rt_thread/src/ipc.c ****         /* change the owner thread to original priority */
 849:./rt_thread/src/ipc.c ****         if (mutex->original_priority != mutex->owner->current_priority)
 850:./rt_thread/src/ipc.c ****         {
 851:./rt_thread/src/ipc.c ****             rt_thread_control(mutex->owner,
 852:./rt_thread/src/ipc.c ****                               RT_THREAD_CTRL_CHANGE_PRIORITY,
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 36


 853:./rt_thread/src/ipc.c ****                               &(mutex->original_priority));
 854:./rt_thread/src/ipc.c ****         }
 855:./rt_thread/src/ipc.c **** 
 856:./rt_thread/src/ipc.c ****         /* wakeup suspended thread */
 857:./rt_thread/src/ipc.c ****         if (!rt_list_isempty(&mutex->parent.suspend_thread))
 858:./rt_thread/src/ipc.c ****         {
 859:./rt_thread/src/ipc.c ****             /* get suspended thread */
 860:./rt_thread/src/ipc.c ****             thread = rt_list_entry(mutex->parent.suspend_thread.next,
 861:./rt_thread/src/ipc.c ****                                    struct rt_thread,
 862:./rt_thread/src/ipc.c ****                                    tlist);
 863:./rt_thread/src/ipc.c **** 
 864:./rt_thread/src/ipc.c ****             RT_DEBUG_LOG(RT_DEBUG_IPC, ("mutex_release: resume thread: %s\n",
 865:./rt_thread/src/ipc.c ****                                         thread->name));
 866:./rt_thread/src/ipc.c **** 
 867:./rt_thread/src/ipc.c ****             /* set new owner and priority */
 868:./rt_thread/src/ipc.c ****             mutex->owner             = thread;
 869:./rt_thread/src/ipc.c ****             mutex->original_priority = thread->current_priority;
 870:./rt_thread/src/ipc.c ****             if(mutex->hold < RT_MUTEX_HOLD_MAX)
 871:./rt_thread/src/ipc.c ****             {
 872:./rt_thread/src/ipc.c ****                 mutex->hold ++;
 873:./rt_thread/src/ipc.c ****             }
 874:./rt_thread/src/ipc.c ****             else
 875:./rt_thread/src/ipc.c ****             {
 876:./rt_thread/src/ipc.c ****                 rt_hw_interrupt_enable(temp); /* enable interrupt */
 877:./rt_thread/src/ipc.c ****                 return -RT_EFULL; /* value overflowed */
 878:./rt_thread/src/ipc.c ****             }
 879:./rt_thread/src/ipc.c **** 
 880:./rt_thread/src/ipc.c ****             /* resume thread */
 881:./rt_thread/src/ipc.c ****             rt_ipc_list_resume(&(mutex->parent.suspend_thread));
 882:./rt_thread/src/ipc.c **** 
 883:./rt_thread/src/ipc.c ****             need_schedule = RT_TRUE;
 884:./rt_thread/src/ipc.c ****         }
 885:./rt_thread/src/ipc.c ****         else
 886:./rt_thread/src/ipc.c ****         {
 887:./rt_thread/src/ipc.c ****             if(mutex->value < RT_MUTEX_VALUE_MAX)
 888:./rt_thread/src/ipc.c ****             {
 889:./rt_thread/src/ipc.c ****                 /* increase value */
 890:./rt_thread/src/ipc.c ****                 mutex->value ++;
 891:./rt_thread/src/ipc.c ****             }
 892:./rt_thread/src/ipc.c ****             else
 893:./rt_thread/src/ipc.c ****             {
 894:./rt_thread/src/ipc.c ****                 rt_hw_interrupt_enable(temp); /* enable interrupt */
 895:./rt_thread/src/ipc.c ****                 return -RT_EFULL; /* value overflowed */
 896:./rt_thread/src/ipc.c ****             }
 897:./rt_thread/src/ipc.c **** 
 898:./rt_thread/src/ipc.c ****             /* clear owner */
 899:./rt_thread/src/ipc.c ****             mutex->owner             = RT_NULL;
 900:./rt_thread/src/ipc.c ****             mutex->original_priority = 0xff;
 901:./rt_thread/src/ipc.c ****         }
 902:./rt_thread/src/ipc.c ****     }
 903:./rt_thread/src/ipc.c **** 
 904:./rt_thread/src/ipc.c ****     /* enable interrupt */
 905:./rt_thread/src/ipc.c ****     rt_hw_interrupt_enable(temp);
 906:./rt_thread/src/ipc.c **** 
 907:./rt_thread/src/ipc.c ****     /* perform a schedule */
 908:./rt_thread/src/ipc.c ****     if (need_schedule == RT_TRUE)
 909:./rt_thread/src/ipc.c ****         rt_schedule();
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 37


 910:./rt_thread/src/ipc.c **** 
 911:./rt_thread/src/ipc.c ****     return RT_EOK;
 912:./rt_thread/src/ipc.c **** }
 913:./rt_thread/src/ipc.c **** 
 914:./rt_thread/src/ipc.c **** /**
 915:./rt_thread/src/ipc.c ****  * This function can get or set some extra attributions of a mutex object.
 916:./rt_thread/src/ipc.c ****  *
 917:./rt_thread/src/ipc.c ****  * @param mutex the mutex object
 918:./rt_thread/src/ipc.c ****  * @param cmd the execution command
 919:./rt_thread/src/ipc.c ****  * @param arg the execution argument
 920:./rt_thread/src/ipc.c ****  *
 921:./rt_thread/src/ipc.c ****  * @return the error code
 922:./rt_thread/src/ipc.c ****  */
 923:./rt_thread/src/ipc.c **** rt_err_t rt_mutex_control(rt_mutex_t mutex, int cmd, void *arg)
 924:./rt_thread/src/ipc.c **** {
 925:./rt_thread/src/ipc.c ****     /* parameter check */
 926:./rt_thread/src/ipc.c ****     RT_ASSERT(mutex != RT_NULL);
 927:./rt_thread/src/ipc.c ****     RT_ASSERT(rt_object_get_type(&mutex->parent.parent) == RT_Object_Class_Mutex);
 928:./rt_thread/src/ipc.c **** 
 929:./rt_thread/src/ipc.c ****     return -RT_ERROR;
 930:./rt_thread/src/ipc.c **** }
 931:./rt_thread/src/ipc.c **** #endif /* end of RT_USING_MUTEX */
 932:./rt_thread/src/ipc.c **** 
 933:./rt_thread/src/ipc.c **** #ifdef RT_USING_EVENT
 934:./rt_thread/src/ipc.c **** /**
 935:./rt_thread/src/ipc.c ****  * This function will initialize an event and put it under control of resource
 936:./rt_thread/src/ipc.c ****  * management.
 937:./rt_thread/src/ipc.c ****  *
 938:./rt_thread/src/ipc.c ****  * @param event the event object
 939:./rt_thread/src/ipc.c ****  * @param name the name of event
 940:./rt_thread/src/ipc.c ****  * @param flag the flag of event
 941:./rt_thread/src/ipc.c ****  *
 942:./rt_thread/src/ipc.c ****  * @return the operation status, RT_EOK on successful
 943:./rt_thread/src/ipc.c ****  */
 944:./rt_thread/src/ipc.c **** rt_err_t rt_event_init(rt_event_t event, const char *name, rt_uint8_t flag)
 945:./rt_thread/src/ipc.c **** {
 946:./rt_thread/src/ipc.c ****     /* parameter check */
 947:./rt_thread/src/ipc.c ****     RT_ASSERT(event != RT_NULL);
 948:./rt_thread/src/ipc.c **** 
 949:./rt_thread/src/ipc.c ****     /* initialize object */
 950:./rt_thread/src/ipc.c ****     rt_object_init(&(event->parent.parent), RT_Object_Class_Event, name);
 951:./rt_thread/src/ipc.c **** 
 952:./rt_thread/src/ipc.c ****     /* set parent flag */
 953:./rt_thread/src/ipc.c ****     event->parent.parent.flag = flag;
 954:./rt_thread/src/ipc.c **** 
 955:./rt_thread/src/ipc.c ****     /* initialize ipc object */
 956:./rt_thread/src/ipc.c ****     rt_ipc_object_init(&(event->parent));
 957:./rt_thread/src/ipc.c **** 
 958:./rt_thread/src/ipc.c ****     /* initialize event */
 959:./rt_thread/src/ipc.c ****     event->set = 0;
 960:./rt_thread/src/ipc.c **** 
 961:./rt_thread/src/ipc.c ****     return RT_EOK;
 962:./rt_thread/src/ipc.c **** }
 963:./rt_thread/src/ipc.c **** 
 964:./rt_thread/src/ipc.c **** /**
 965:./rt_thread/src/ipc.c ****  * This function will detach an event object from resource management
 966:./rt_thread/src/ipc.c ****  *
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 38


 967:./rt_thread/src/ipc.c ****  * @param event the event object
 968:./rt_thread/src/ipc.c ****  *
 969:./rt_thread/src/ipc.c ****  * @return the operation status, RT_EOK on successful
 970:./rt_thread/src/ipc.c ****  */
 971:./rt_thread/src/ipc.c **** rt_err_t rt_event_detach(rt_event_t event)
 972:./rt_thread/src/ipc.c **** {
 973:./rt_thread/src/ipc.c ****     /* parameter check */
 974:./rt_thread/src/ipc.c ****     RT_ASSERT(event != RT_NULL);
 975:./rt_thread/src/ipc.c ****     RT_ASSERT(rt_object_get_type(&event->parent.parent) == RT_Object_Class_Event);
 976:./rt_thread/src/ipc.c ****     RT_ASSERT(rt_object_is_systemobject(&event->parent.parent));
 977:./rt_thread/src/ipc.c **** 
 978:./rt_thread/src/ipc.c ****     /* resume all suspended thread */
 979:./rt_thread/src/ipc.c ****     rt_ipc_list_resume_all(&(event->parent.suspend_thread));
 980:./rt_thread/src/ipc.c **** 
 981:./rt_thread/src/ipc.c ****     /* detach event object */
 982:./rt_thread/src/ipc.c ****     rt_object_detach(&(event->parent.parent));
 983:./rt_thread/src/ipc.c **** 
 984:./rt_thread/src/ipc.c ****     return RT_EOK;
 985:./rt_thread/src/ipc.c **** }
 986:./rt_thread/src/ipc.c **** 
 987:./rt_thread/src/ipc.c **** #ifdef RT_USING_HEAP
 988:./rt_thread/src/ipc.c **** /**
 989:./rt_thread/src/ipc.c ****  * This function will create an event object from system resource
 990:./rt_thread/src/ipc.c ****  *
 991:./rt_thread/src/ipc.c ****  * @param name the name of event
 992:./rt_thread/src/ipc.c ****  * @param flag the flag of event
 993:./rt_thread/src/ipc.c ****  *
 994:./rt_thread/src/ipc.c ****  * @return the created event, RT_NULL on error happen
 995:./rt_thread/src/ipc.c ****  */
 996:./rt_thread/src/ipc.c **** rt_event_t rt_event_create(const char *name, rt_uint8_t flag)
 997:./rt_thread/src/ipc.c **** {
 998:./rt_thread/src/ipc.c ****     rt_event_t event;
 999:./rt_thread/src/ipc.c **** 
1000:./rt_thread/src/ipc.c ****     RT_DEBUG_NOT_IN_INTERRUPT;
1001:./rt_thread/src/ipc.c **** 
1002:./rt_thread/src/ipc.c ****     /* allocate object */
1003:./rt_thread/src/ipc.c ****     event = (rt_event_t)rt_object_allocate(RT_Object_Class_Event, name);
1004:./rt_thread/src/ipc.c ****     if (event == RT_NULL)
1005:./rt_thread/src/ipc.c ****         return event;
1006:./rt_thread/src/ipc.c **** 
1007:./rt_thread/src/ipc.c ****     /* set parent */
1008:./rt_thread/src/ipc.c ****     event->parent.parent.flag = flag;
1009:./rt_thread/src/ipc.c **** 
1010:./rt_thread/src/ipc.c ****     /* initialize ipc object */
1011:./rt_thread/src/ipc.c ****     rt_ipc_object_init(&(event->parent));
1012:./rt_thread/src/ipc.c **** 
1013:./rt_thread/src/ipc.c ****     /* initialize event */
1014:./rt_thread/src/ipc.c ****     event->set = 0;
1015:./rt_thread/src/ipc.c **** 
1016:./rt_thread/src/ipc.c ****     return event;
1017:./rt_thread/src/ipc.c **** }
1018:./rt_thread/src/ipc.c **** 
1019:./rt_thread/src/ipc.c **** /**
1020:./rt_thread/src/ipc.c ****  * This function will delete an event object and release the memory
1021:./rt_thread/src/ipc.c ****  *
1022:./rt_thread/src/ipc.c ****  * @param event the event object
1023:./rt_thread/src/ipc.c ****  *
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 39


1024:./rt_thread/src/ipc.c ****  * @return the error code
1025:./rt_thread/src/ipc.c ****  */
1026:./rt_thread/src/ipc.c **** rt_err_t rt_event_delete(rt_event_t event)
1027:./rt_thread/src/ipc.c **** {
1028:./rt_thread/src/ipc.c ****     /* parameter check */
1029:./rt_thread/src/ipc.c ****     RT_ASSERT(event != RT_NULL);
1030:./rt_thread/src/ipc.c ****     RT_ASSERT(rt_object_get_type(&event->parent.parent) == RT_Object_Class_Event);
1031:./rt_thread/src/ipc.c ****     RT_ASSERT(rt_object_is_systemobject(&event->parent.parent) == RT_FALSE);
1032:./rt_thread/src/ipc.c **** 
1033:./rt_thread/src/ipc.c ****     RT_DEBUG_NOT_IN_INTERRUPT;
1034:./rt_thread/src/ipc.c **** 
1035:./rt_thread/src/ipc.c ****     /* resume all suspended thread */
1036:./rt_thread/src/ipc.c ****     rt_ipc_list_resume_all(&(event->parent.suspend_thread));
1037:./rt_thread/src/ipc.c **** 
1038:./rt_thread/src/ipc.c ****     /* delete event object */
1039:./rt_thread/src/ipc.c ****     rt_object_delete(&(event->parent.parent));
1040:./rt_thread/src/ipc.c **** 
1041:./rt_thread/src/ipc.c ****     return RT_EOK;
1042:./rt_thread/src/ipc.c **** }
1043:./rt_thread/src/ipc.c **** #endif
1044:./rt_thread/src/ipc.c **** 
1045:./rt_thread/src/ipc.c **** /**
1046:./rt_thread/src/ipc.c ****  * This function will send an event to the event object, if there are threads
1047:./rt_thread/src/ipc.c ****  * suspended on event object, it will be waked up.
1048:./rt_thread/src/ipc.c ****  *
1049:./rt_thread/src/ipc.c ****  * @param event the event object
1050:./rt_thread/src/ipc.c ****  * @param set the event set
1051:./rt_thread/src/ipc.c ****  *
1052:./rt_thread/src/ipc.c ****  * @return the error code
1053:./rt_thread/src/ipc.c ****  */
1054:./rt_thread/src/ipc.c **** rt_err_t rt_event_send(rt_event_t event, rt_uint32_t set)
1055:./rt_thread/src/ipc.c **** {
1056:./rt_thread/src/ipc.c ****     struct rt_list_node *n;
1057:./rt_thread/src/ipc.c ****     struct rt_thread *thread;
1058:./rt_thread/src/ipc.c ****     register rt_ubase_t level;
1059:./rt_thread/src/ipc.c ****     register rt_base_t status;
1060:./rt_thread/src/ipc.c ****     rt_bool_t need_schedule;
1061:./rt_thread/src/ipc.c **** 
1062:./rt_thread/src/ipc.c ****     /* parameter check */
1063:./rt_thread/src/ipc.c ****     RT_ASSERT(event != RT_NULL);
1064:./rt_thread/src/ipc.c ****     RT_ASSERT(rt_object_get_type(&event->parent.parent) == RT_Object_Class_Event);
1065:./rt_thread/src/ipc.c **** 
1066:./rt_thread/src/ipc.c ****     if (set == 0)
1067:./rt_thread/src/ipc.c ****         return -RT_ERROR;
1068:./rt_thread/src/ipc.c **** 
1069:./rt_thread/src/ipc.c ****     need_schedule = RT_FALSE;
1070:./rt_thread/src/ipc.c **** 
1071:./rt_thread/src/ipc.c ****     /* disable interrupt */
1072:./rt_thread/src/ipc.c ****     level = rt_hw_interrupt_disable();
1073:./rt_thread/src/ipc.c **** 
1074:./rt_thread/src/ipc.c ****     /* set event */
1075:./rt_thread/src/ipc.c ****     event->set |= set;
1076:./rt_thread/src/ipc.c **** 
1077:./rt_thread/src/ipc.c ****     RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(event->parent.parent)));
1078:./rt_thread/src/ipc.c **** 
1079:./rt_thread/src/ipc.c ****     if (!rt_list_isempty(&event->parent.suspend_thread))
1080:./rt_thread/src/ipc.c ****     {
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 40


1081:./rt_thread/src/ipc.c ****         /* search thread list to resume thread */
1082:./rt_thread/src/ipc.c ****         n = event->parent.suspend_thread.next;
1083:./rt_thread/src/ipc.c ****         while (n != &(event->parent.suspend_thread))
1084:./rt_thread/src/ipc.c ****         {
1085:./rt_thread/src/ipc.c ****             /* get thread */
1086:./rt_thread/src/ipc.c ****             thread = rt_list_entry(n, struct rt_thread, tlist);
1087:./rt_thread/src/ipc.c **** 
1088:./rt_thread/src/ipc.c ****             status = -RT_ERROR;
1089:./rt_thread/src/ipc.c ****             if (thread->event_info & RT_EVENT_FLAG_AND)
1090:./rt_thread/src/ipc.c ****             {
1091:./rt_thread/src/ipc.c ****                 if ((thread->event_set & event->set) == thread->event_set)
1092:./rt_thread/src/ipc.c ****                 {
1093:./rt_thread/src/ipc.c ****                     /* received an AND event */
1094:./rt_thread/src/ipc.c ****                     status = RT_EOK;
1095:./rt_thread/src/ipc.c ****                 }
1096:./rt_thread/src/ipc.c ****             }
1097:./rt_thread/src/ipc.c ****             else if (thread->event_info & RT_EVENT_FLAG_OR)
1098:./rt_thread/src/ipc.c ****             {
1099:./rt_thread/src/ipc.c ****                 if (thread->event_set & event->set)
1100:./rt_thread/src/ipc.c ****                 {
1101:./rt_thread/src/ipc.c ****                     /* save the received event set */
1102:./rt_thread/src/ipc.c ****                     thread->event_set = thread->event_set & event->set;
1103:./rt_thread/src/ipc.c **** 
1104:./rt_thread/src/ipc.c ****                     /* received an OR event */
1105:./rt_thread/src/ipc.c ****                     status = RT_EOK;
1106:./rt_thread/src/ipc.c ****                 }
1107:./rt_thread/src/ipc.c ****             }
1108:./rt_thread/src/ipc.c ****             else
1109:./rt_thread/src/ipc.c ****             {
1110:./rt_thread/src/ipc.c ****                 /* enable interrupt */
1111:./rt_thread/src/ipc.c ****                 rt_hw_interrupt_enable(level);
1112:./rt_thread/src/ipc.c **** 
1113:./rt_thread/src/ipc.c ****                 return -RT_EINVAL;
1114:./rt_thread/src/ipc.c ****             }
1115:./rt_thread/src/ipc.c **** 
1116:./rt_thread/src/ipc.c ****             /* move node to the next */
1117:./rt_thread/src/ipc.c ****             n = n->next;
1118:./rt_thread/src/ipc.c **** 
1119:./rt_thread/src/ipc.c ****             /* condition is satisfied, resume thread */
1120:./rt_thread/src/ipc.c ****             if (status == RT_EOK)
1121:./rt_thread/src/ipc.c ****             {
1122:./rt_thread/src/ipc.c ****                 /* clear event */
1123:./rt_thread/src/ipc.c ****                 if (thread->event_info & RT_EVENT_FLAG_CLEAR)
1124:./rt_thread/src/ipc.c ****                     event->set &= ~thread->event_set;
1125:./rt_thread/src/ipc.c **** 
1126:./rt_thread/src/ipc.c ****                 /* resume thread, and thread list breaks out */
1127:./rt_thread/src/ipc.c ****                 rt_thread_resume(thread);
1128:./rt_thread/src/ipc.c **** 
1129:./rt_thread/src/ipc.c ****                 /* need do a scheduling */
1130:./rt_thread/src/ipc.c ****                 need_schedule = RT_TRUE;
1131:./rt_thread/src/ipc.c ****             }
1132:./rt_thread/src/ipc.c ****         }
1133:./rt_thread/src/ipc.c ****     }
1134:./rt_thread/src/ipc.c **** 
1135:./rt_thread/src/ipc.c ****     /* enable interrupt */
1136:./rt_thread/src/ipc.c ****     rt_hw_interrupt_enable(level);
1137:./rt_thread/src/ipc.c **** 
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 41


1138:./rt_thread/src/ipc.c ****     /* do a schedule */
1139:./rt_thread/src/ipc.c ****     if (need_schedule == RT_TRUE)
1140:./rt_thread/src/ipc.c ****         rt_schedule();
1141:./rt_thread/src/ipc.c **** 
1142:./rt_thread/src/ipc.c ****     return RT_EOK;
1143:./rt_thread/src/ipc.c **** }
1144:./rt_thread/src/ipc.c **** 
1145:./rt_thread/src/ipc.c **** /**
1146:./rt_thread/src/ipc.c ****  * This function will receive an event from event object, if the event is
1147:./rt_thread/src/ipc.c ****  * unavailable, the thread shall wait for a specified time.
1148:./rt_thread/src/ipc.c ****  *
1149:./rt_thread/src/ipc.c ****  * @param event the fast event object
1150:./rt_thread/src/ipc.c ****  * @param set the interested event set
1151:./rt_thread/src/ipc.c ****  * @param option the receive option, either RT_EVENT_FLAG_AND or
1152:./rt_thread/src/ipc.c ****  *        RT_EVENT_FLAG_OR should be set.
1153:./rt_thread/src/ipc.c ****  * @param timeout the waiting time
1154:./rt_thread/src/ipc.c ****  * @param recved the received event, if you don't care, RT_NULL can be set.
1155:./rt_thread/src/ipc.c ****  *
1156:./rt_thread/src/ipc.c ****  * @return the error code
1157:./rt_thread/src/ipc.c ****  */
1158:./rt_thread/src/ipc.c **** rt_err_t rt_event_recv(rt_event_t   event,
1159:./rt_thread/src/ipc.c ****                        rt_uint32_t  set,
1160:./rt_thread/src/ipc.c ****                        rt_uint8_t   option,
1161:./rt_thread/src/ipc.c ****                        rt_int32_t   timeout,
1162:./rt_thread/src/ipc.c ****                        rt_uint32_t *recved)
1163:./rt_thread/src/ipc.c **** {
1164:./rt_thread/src/ipc.c ****     struct rt_thread *thread;
1165:./rt_thread/src/ipc.c ****     register rt_ubase_t level;
1166:./rt_thread/src/ipc.c ****     register rt_base_t status;
1167:./rt_thread/src/ipc.c **** 
1168:./rt_thread/src/ipc.c ****     RT_DEBUG_IN_THREAD_CONTEXT;
1169:./rt_thread/src/ipc.c **** 
1170:./rt_thread/src/ipc.c ****     /* parameter check */
1171:./rt_thread/src/ipc.c ****     RT_ASSERT(event != RT_NULL);
1172:./rt_thread/src/ipc.c ****     RT_ASSERT(rt_object_get_type(&event->parent.parent) == RT_Object_Class_Event);
1173:./rt_thread/src/ipc.c **** 
1174:./rt_thread/src/ipc.c ****     if (set == 0)
1175:./rt_thread/src/ipc.c ****         return -RT_ERROR;
1176:./rt_thread/src/ipc.c **** 
1177:./rt_thread/src/ipc.c ****     /* initialize status */
1178:./rt_thread/src/ipc.c ****     status = -RT_ERROR;
1179:./rt_thread/src/ipc.c ****     /* get current thread */
1180:./rt_thread/src/ipc.c ****     thread = rt_thread_self();
1181:./rt_thread/src/ipc.c ****     /* reset thread error */
1182:./rt_thread/src/ipc.c ****     thread->error = RT_EOK;
1183:./rt_thread/src/ipc.c **** 
1184:./rt_thread/src/ipc.c ****     RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(event->parent.parent)));
1185:./rt_thread/src/ipc.c **** 
1186:./rt_thread/src/ipc.c ****     /* disable interrupt */
1187:./rt_thread/src/ipc.c ****     level = rt_hw_interrupt_disable();
1188:./rt_thread/src/ipc.c **** 
1189:./rt_thread/src/ipc.c ****     /* check event set */
1190:./rt_thread/src/ipc.c ****     if (option & RT_EVENT_FLAG_AND)
1191:./rt_thread/src/ipc.c ****     {
1192:./rt_thread/src/ipc.c ****         if ((event->set & set) == set)
1193:./rt_thread/src/ipc.c ****             status = RT_EOK;
1194:./rt_thread/src/ipc.c ****     }
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 42


1195:./rt_thread/src/ipc.c ****     else if (option & RT_EVENT_FLAG_OR)
1196:./rt_thread/src/ipc.c ****     {
1197:./rt_thread/src/ipc.c ****         if (event->set & set)
1198:./rt_thread/src/ipc.c ****             status = RT_EOK;
1199:./rt_thread/src/ipc.c ****     }
1200:./rt_thread/src/ipc.c ****     else
1201:./rt_thread/src/ipc.c ****     {
1202:./rt_thread/src/ipc.c ****         /* either RT_EVENT_FLAG_AND or RT_EVENT_FLAG_OR should be set */
1203:./rt_thread/src/ipc.c ****         RT_ASSERT(0);
1204:./rt_thread/src/ipc.c ****     }
1205:./rt_thread/src/ipc.c **** 
1206:./rt_thread/src/ipc.c ****     if (status == RT_EOK)
1207:./rt_thread/src/ipc.c ****     {
1208:./rt_thread/src/ipc.c ****         /* set received event */
1209:./rt_thread/src/ipc.c ****         if (recved)
1210:./rt_thread/src/ipc.c ****             *recved = (event->set & set);
1211:./rt_thread/src/ipc.c **** 
1212:./rt_thread/src/ipc.c ****         /* fill thread event info */
1213:./rt_thread/src/ipc.c ****         thread->event_set = (event->set & set);
1214:./rt_thread/src/ipc.c ****         thread->event_info = option;
1215:./rt_thread/src/ipc.c **** 
1216:./rt_thread/src/ipc.c ****         /* received event */
1217:./rt_thread/src/ipc.c ****         if (option & RT_EVENT_FLAG_CLEAR)
1218:./rt_thread/src/ipc.c ****             event->set &= ~set;
1219:./rt_thread/src/ipc.c ****     }
1220:./rt_thread/src/ipc.c ****     else if (timeout == 0)
1221:./rt_thread/src/ipc.c ****     {
1222:./rt_thread/src/ipc.c ****         /* no waiting */
1223:./rt_thread/src/ipc.c ****         thread->error = -RT_ETIMEOUT;
1224:./rt_thread/src/ipc.c **** 
1225:./rt_thread/src/ipc.c ****         /* enable interrupt */
1226:./rt_thread/src/ipc.c ****         rt_hw_interrupt_enable(level);
1227:./rt_thread/src/ipc.c **** 
1228:./rt_thread/src/ipc.c ****         return -RT_ETIMEOUT;
1229:./rt_thread/src/ipc.c ****     }
1230:./rt_thread/src/ipc.c ****     else
1231:./rt_thread/src/ipc.c ****     {
1232:./rt_thread/src/ipc.c ****         /* fill thread event info */
1233:./rt_thread/src/ipc.c ****         thread->event_set  = set;
1234:./rt_thread/src/ipc.c ****         thread->event_info = option;
1235:./rt_thread/src/ipc.c **** 
1236:./rt_thread/src/ipc.c ****         /* put thread to suspended thread list */
1237:./rt_thread/src/ipc.c ****         rt_ipc_list_suspend(&(event->parent.suspend_thread),
1238:./rt_thread/src/ipc.c ****                             thread,
1239:./rt_thread/src/ipc.c ****                             event->parent.parent.flag);
1240:./rt_thread/src/ipc.c **** 
1241:./rt_thread/src/ipc.c ****         /* if there is a waiting timeout, active thread timer */
1242:./rt_thread/src/ipc.c ****         if (timeout > 0)
1243:./rt_thread/src/ipc.c ****         {
1244:./rt_thread/src/ipc.c ****             /* reset the timeout of thread timer and start it */
1245:./rt_thread/src/ipc.c ****             rt_timer_control(&(thread->thread_timer),
1246:./rt_thread/src/ipc.c ****                              RT_TIMER_CTRL_SET_TIME,
1247:./rt_thread/src/ipc.c ****                              &timeout);
1248:./rt_thread/src/ipc.c ****             rt_timer_start(&(thread->thread_timer));
1249:./rt_thread/src/ipc.c ****         }
1250:./rt_thread/src/ipc.c **** 
1251:./rt_thread/src/ipc.c ****         /* enable interrupt */
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 43


1252:./rt_thread/src/ipc.c ****         rt_hw_interrupt_enable(level);
1253:./rt_thread/src/ipc.c **** 
1254:./rt_thread/src/ipc.c ****         /* do a schedule */
1255:./rt_thread/src/ipc.c ****         rt_schedule();
1256:./rt_thread/src/ipc.c **** 
1257:./rt_thread/src/ipc.c ****         if (thread->error != RT_EOK)
1258:./rt_thread/src/ipc.c ****         {
1259:./rt_thread/src/ipc.c ****             /* return error */
1260:./rt_thread/src/ipc.c ****             return thread->error;
1261:./rt_thread/src/ipc.c ****         }
1262:./rt_thread/src/ipc.c **** 
1263:./rt_thread/src/ipc.c ****         /* received an event, disable interrupt to protect */
1264:./rt_thread/src/ipc.c ****         level = rt_hw_interrupt_disable();
1265:./rt_thread/src/ipc.c **** 
1266:./rt_thread/src/ipc.c ****         /* set received event */
1267:./rt_thread/src/ipc.c ****         if (recved)
1268:./rt_thread/src/ipc.c ****             *recved = thread->event_set;
1269:./rt_thread/src/ipc.c ****     }
1270:./rt_thread/src/ipc.c **** 
1271:./rt_thread/src/ipc.c ****     /* enable interrupt */
1272:./rt_thread/src/ipc.c ****     rt_hw_interrupt_enable(level);
1273:./rt_thread/src/ipc.c **** 
1274:./rt_thread/src/ipc.c ****     RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(event->parent.parent)));
1275:./rt_thread/src/ipc.c **** 
1276:./rt_thread/src/ipc.c ****     return thread->error;
1277:./rt_thread/src/ipc.c **** }
1278:./rt_thread/src/ipc.c **** 
1279:./rt_thread/src/ipc.c **** /**
1280:./rt_thread/src/ipc.c ****  * This function can get or set some extra attributions of an event object.
1281:./rt_thread/src/ipc.c ****  *
1282:./rt_thread/src/ipc.c ****  * @param event the event object
1283:./rt_thread/src/ipc.c ****  * @param cmd the execution command
1284:./rt_thread/src/ipc.c ****  * @param arg the execution argument
1285:./rt_thread/src/ipc.c ****  *
1286:./rt_thread/src/ipc.c ****  * @return the error code
1287:./rt_thread/src/ipc.c ****  */
1288:./rt_thread/src/ipc.c **** rt_err_t rt_event_control(rt_event_t event, int cmd, void *arg)
1289:./rt_thread/src/ipc.c **** {
1290:./rt_thread/src/ipc.c ****     rt_ubase_t level;
1291:./rt_thread/src/ipc.c **** 
1292:./rt_thread/src/ipc.c ****     /* parameter check */
1293:./rt_thread/src/ipc.c ****     RT_ASSERT(event != RT_NULL);
1294:./rt_thread/src/ipc.c ****     RT_ASSERT(rt_object_get_type(&event->parent.parent) == RT_Object_Class_Event);
1295:./rt_thread/src/ipc.c **** 
1296:./rt_thread/src/ipc.c ****     if (cmd == RT_IPC_CMD_RESET)
1297:./rt_thread/src/ipc.c ****     {
1298:./rt_thread/src/ipc.c ****         /* disable interrupt */
1299:./rt_thread/src/ipc.c ****         level = rt_hw_interrupt_disable();
1300:./rt_thread/src/ipc.c **** 
1301:./rt_thread/src/ipc.c ****         /* resume all waiting thread */
1302:./rt_thread/src/ipc.c ****         rt_ipc_list_resume_all(&event->parent.suspend_thread);
1303:./rt_thread/src/ipc.c **** 
1304:./rt_thread/src/ipc.c ****         /* initialize event set */
1305:./rt_thread/src/ipc.c ****         event->set = 0;
1306:./rt_thread/src/ipc.c **** 
1307:./rt_thread/src/ipc.c ****         /* enable interrupt */
1308:./rt_thread/src/ipc.c ****         rt_hw_interrupt_enable(level);
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 44


1309:./rt_thread/src/ipc.c **** 
1310:./rt_thread/src/ipc.c ****         rt_schedule();
1311:./rt_thread/src/ipc.c **** 
1312:./rt_thread/src/ipc.c ****         return RT_EOK;
1313:./rt_thread/src/ipc.c ****     }
1314:./rt_thread/src/ipc.c **** 
1315:./rt_thread/src/ipc.c ****     return -RT_ERROR;
1316:./rt_thread/src/ipc.c **** }
1317:./rt_thread/src/ipc.c **** #endif /* end of RT_USING_EVENT */
1318:./rt_thread/src/ipc.c **** 
1319:./rt_thread/src/ipc.c **** #ifdef RT_USING_MAILBOX
1320:./rt_thread/src/ipc.c **** /**
1321:./rt_thread/src/ipc.c ****  * This function will initialize a mailbox and put it under control of resource
1322:./rt_thread/src/ipc.c ****  * management.
1323:./rt_thread/src/ipc.c ****  *
1324:./rt_thread/src/ipc.c ****  * @param mb the mailbox object
1325:./rt_thread/src/ipc.c ****  * @param name the name of mailbox
1326:./rt_thread/src/ipc.c ****  * @param msgpool the begin address of buffer to save received mail
1327:./rt_thread/src/ipc.c ****  * @param size the size of mailbox
1328:./rt_thread/src/ipc.c ****  * @param flag the flag of mailbox
1329:./rt_thread/src/ipc.c ****  *
1330:./rt_thread/src/ipc.c ****  * @return the operation status, RT_EOK on successful
1331:./rt_thread/src/ipc.c ****  */
1332:./rt_thread/src/ipc.c **** rt_err_t rt_mb_init(rt_mailbox_t mb,
1333:./rt_thread/src/ipc.c ****                     const char  *name,
1334:./rt_thread/src/ipc.c ****                     void        *msgpool,
1335:./rt_thread/src/ipc.c ****                     rt_size_t    size,
1336:./rt_thread/src/ipc.c ****                     rt_uint8_t   flag)
1337:./rt_thread/src/ipc.c **** {
 1057              		.loc 2 1337 1
 1058              		.cfi_startproc
 1059              		@ args = 4, pretend = 0, frame = 16
 1060              		@ frame_needed = 1, uses_anonymous_args = 0
 1061 0000 80B5     		push	{r7, lr}
 1062              	.LCFI78:
 1063              		.cfi_def_cfa_offset 8
 1064              		.cfi_offset 7, -8
 1065              		.cfi_offset 14, -4
 1066 0002 84B0     		sub	sp, sp, #16
 1067              	.LCFI79:
 1068              		.cfi_def_cfa_offset 24
 1069 0004 00AF     		add	r7, sp, #0
 1070              	.LCFI80:
 1071              		.cfi_def_cfa_register 7
 1072 0006 F860     		str	r0, [r7, #12]
 1073 0008 B960     		str	r1, [r7, #8]
 1074 000a 7A60     		str	r2, [r7, #4]
 1075 000c 3B60     		str	r3, [r7]
1338:./rt_thread/src/ipc.c ****     RT_ASSERT(mb != RT_NULL);
1339:./rt_thread/src/ipc.c **** 
1340:./rt_thread/src/ipc.c ****     /* initialize object */
1341:./rt_thread/src/ipc.c ****     rt_object_init(&(mb->parent.parent), RT_Object_Class_MailBox, name);
 1076              		.loc 2 1341 5
 1077 000e FB68     		ldr	r3, [r7, #12]
 1078 0010 BA68     		ldr	r2, [r7, #8]
 1079 0012 0521     		movs	r1, #5
 1080 0014 1846     		mov	r0, r3
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 45


 1081 0016 FFF7FEFF 		bl	rt_object_init
1342:./rt_thread/src/ipc.c **** 
1343:./rt_thread/src/ipc.c ****     /* set parent flag */
1344:./rt_thread/src/ipc.c ****     mb->parent.parent.flag = flag;
 1082              		.loc 2 1344 28
 1083 001a FB68     		ldr	r3, [r7, #12]
 1084 001c 3A7E     		ldrb	r2, [r7, #24]
 1085 001e 5A72     		strb	r2, [r3, #9]
1345:./rt_thread/src/ipc.c **** 
1346:./rt_thread/src/ipc.c ****     /* initialize ipc object */
1347:./rt_thread/src/ipc.c ****     rt_ipc_object_init(&(mb->parent));
 1086              		.loc 2 1347 5
 1087 0020 FB68     		ldr	r3, [r7, #12]
 1088 0022 1846     		mov	r0, r3
 1089 0024 FFF7FEFF 		bl	rt_ipc_object_init
1348:./rt_thread/src/ipc.c **** 
1349:./rt_thread/src/ipc.c ****     /* initialize mailbox */
1350:./rt_thread/src/ipc.c ****     mb->msg_pool   = (rt_ubase_t *)msgpool;
 1090              		.loc 2 1350 20
 1091 0028 FB68     		ldr	r3, [r7, #12]
 1092 002a 7A68     		ldr	r2, [r7, #4]
 1093 002c DA61     		str	r2, [r3, #28]
1351:./rt_thread/src/ipc.c ****     mb->size       = size;
 1094              		.loc 2 1351 20
 1095 002e 3B68     		ldr	r3, [r7]
 1096 0030 9AB2     		uxth	r2, r3
 1097 0032 FB68     		ldr	r3, [r7, #12]
 1098 0034 1A84     		strh	r2, [r3, #32]	@ movhi
1352:./rt_thread/src/ipc.c ****     mb->entry      = 0;
 1099              		.loc 2 1352 20
 1100 0036 FB68     		ldr	r3, [r7, #12]
 1101 0038 0022     		movs	r2, #0
 1102 003a 5A84     		strh	r2, [r3, #34]	@ movhi
1353:./rt_thread/src/ipc.c ****     mb->in_offset  = 0;
 1103              		.loc 2 1353 20
 1104 003c FB68     		ldr	r3, [r7, #12]
 1105 003e 0022     		movs	r2, #0
 1106 0040 9A84     		strh	r2, [r3, #36]	@ movhi
1354:./rt_thread/src/ipc.c ****     mb->out_offset = 0;
 1107              		.loc 2 1354 20
 1108 0042 FB68     		ldr	r3, [r7, #12]
 1109 0044 0022     		movs	r2, #0
 1110 0046 DA84     		strh	r2, [r3, #38]	@ movhi
1355:./rt_thread/src/ipc.c **** 
1356:./rt_thread/src/ipc.c ****     /* initialize an additional list of sender suspend thread */
1357:./rt_thread/src/ipc.c ****     rt_list_init(&(mb->suspend_sender_thread));
 1111              		.loc 2 1357 5
 1112 0048 FB68     		ldr	r3, [r7, #12]
 1113 004a 2833     		adds	r3, r3, #40
 1114 004c 1846     		mov	r0, r3
 1115 004e FFF7FEFF 		bl	rt_list_init
1358:./rt_thread/src/ipc.c **** 
1359:./rt_thread/src/ipc.c ****     return RT_EOK;
 1116              		.loc 2 1359 12
 1117 0052 0023     		movs	r3, #0
1360:./rt_thread/src/ipc.c **** }
 1118              		.loc 2 1360 1
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 46


 1119 0054 1846     		mov	r0, r3
 1120 0056 1037     		adds	r7, r7, #16
 1121              	.LCFI81:
 1122              		.cfi_def_cfa_offset 8
 1123 0058 BD46     		mov	sp, r7
 1124              	.LCFI82:
 1125              		.cfi_def_cfa_register 13
 1126              		@ sp needed
 1127 005a 80BD     		pop	{r7, pc}
 1128              		.cfi_endproc
 1129              	.LFE27:
 1131              		.section	.text.rt_mb_detach,"ax",%progbits
 1132              		.align	1
 1133              		.global	rt_mb_detach
 1134              		.syntax unified
 1135              		.thumb
 1136              		.thumb_func
 1138              	rt_mb_detach:
 1139              	.LFB28:
1361:./rt_thread/src/ipc.c **** 
1362:./rt_thread/src/ipc.c **** /**
1363:./rt_thread/src/ipc.c ****  * This function will detach a mailbox from resource management
1364:./rt_thread/src/ipc.c ****  *
1365:./rt_thread/src/ipc.c ****  * @param mb the mailbox object
1366:./rt_thread/src/ipc.c ****  *
1367:./rt_thread/src/ipc.c ****  * @return the operation status, RT_EOK on successful
1368:./rt_thread/src/ipc.c ****  */
1369:./rt_thread/src/ipc.c **** rt_err_t rt_mb_detach(rt_mailbox_t mb)
1370:./rt_thread/src/ipc.c **** {
 1140              		.loc 2 1370 1
 1141              		.cfi_startproc
 1142              		@ args = 0, pretend = 0, frame = 8
 1143              		@ frame_needed = 1, uses_anonymous_args = 0
 1144 0000 80B5     		push	{r7, lr}
 1145              	.LCFI83:
 1146              		.cfi_def_cfa_offset 8
 1147              		.cfi_offset 7, -8
 1148              		.cfi_offset 14, -4
 1149 0002 82B0     		sub	sp, sp, #8
 1150              	.LCFI84:
 1151              		.cfi_def_cfa_offset 16
 1152 0004 00AF     		add	r7, sp, #0
 1153              	.LCFI85:
 1154              		.cfi_def_cfa_register 7
 1155 0006 7860     		str	r0, [r7, #4]
1371:./rt_thread/src/ipc.c ****     /* parameter check */
1372:./rt_thread/src/ipc.c ****     RT_ASSERT(mb != RT_NULL);
1373:./rt_thread/src/ipc.c ****     RT_ASSERT(rt_object_get_type(&mb->parent.parent) == RT_Object_Class_MailBox);
1374:./rt_thread/src/ipc.c ****     RT_ASSERT(rt_object_is_systemobject(&mb->parent.parent));
1375:./rt_thread/src/ipc.c **** 
1376:./rt_thread/src/ipc.c ****     /* resume all suspended thread */
1377:./rt_thread/src/ipc.c ****     rt_ipc_list_resume_all(&(mb->parent.suspend_thread));
 1156              		.loc 2 1377 5
 1157 0008 7B68     		ldr	r3, [r7, #4]
 1158 000a 1433     		adds	r3, r3, #20
 1159 000c 1846     		mov	r0, r3
 1160 000e FFF7FEFF 		bl	rt_ipc_list_resume_all
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 47


1378:./rt_thread/src/ipc.c ****     /* also resume all mailbox private suspended thread */
1379:./rt_thread/src/ipc.c ****     rt_ipc_list_resume_all(&(mb->suspend_sender_thread));
 1161              		.loc 2 1379 5
 1162 0012 7B68     		ldr	r3, [r7, #4]
 1163 0014 2833     		adds	r3, r3, #40
 1164 0016 1846     		mov	r0, r3
 1165 0018 FFF7FEFF 		bl	rt_ipc_list_resume_all
1380:./rt_thread/src/ipc.c **** 
1381:./rt_thread/src/ipc.c ****     /* detach mailbox object */
1382:./rt_thread/src/ipc.c ****     rt_object_detach(&(mb->parent.parent));
 1166              		.loc 2 1382 5
 1167 001c 7B68     		ldr	r3, [r7, #4]
 1168 001e 1846     		mov	r0, r3
 1169 0020 FFF7FEFF 		bl	rt_object_detach
1383:./rt_thread/src/ipc.c **** 
1384:./rt_thread/src/ipc.c ****     return RT_EOK;
 1170              		.loc 2 1384 12
 1171 0024 0023     		movs	r3, #0
1385:./rt_thread/src/ipc.c **** }
 1172              		.loc 2 1385 1
 1173 0026 1846     		mov	r0, r3
 1174 0028 0837     		adds	r7, r7, #8
 1175              	.LCFI86:
 1176              		.cfi_def_cfa_offset 8
 1177 002a BD46     		mov	sp, r7
 1178              	.LCFI87:
 1179              		.cfi_def_cfa_register 13
 1180              		@ sp needed
 1181 002c 80BD     		pop	{r7, pc}
 1182              		.cfi_endproc
 1183              	.LFE28:
 1185              		.section	.text.rt_mb_create,"ax",%progbits
 1186              		.align	1
 1187              		.global	rt_mb_create
 1188              		.syntax unified
 1189              		.thumb
 1190              		.thumb_func
 1192              	rt_mb_create:
 1193              	.LFB29:
1386:./rt_thread/src/ipc.c **** 
1387:./rt_thread/src/ipc.c **** #ifdef RT_USING_HEAP
1388:./rt_thread/src/ipc.c **** /**
1389:./rt_thread/src/ipc.c ****  * This function will create a mailbox object from system resource
1390:./rt_thread/src/ipc.c ****  *
1391:./rt_thread/src/ipc.c ****  * @param name the name of mailbox
1392:./rt_thread/src/ipc.c ****  * @param size the size of mailbox
1393:./rt_thread/src/ipc.c ****  * @param flag the flag of mailbox
1394:./rt_thread/src/ipc.c ****  *
1395:./rt_thread/src/ipc.c ****  * @return the created mailbox, RT_NULL on error happen
1396:./rt_thread/src/ipc.c ****  */
1397:./rt_thread/src/ipc.c **** rt_mailbox_t rt_mb_create(const char *name, rt_size_t size, rt_uint8_t flag)
1398:./rt_thread/src/ipc.c **** {
 1194              		.loc 2 1398 1
 1195              		.cfi_startproc
 1196              		@ args = 0, pretend = 0, frame = 24
 1197              		@ frame_needed = 1, uses_anonymous_args = 0
 1198 0000 80B5     		push	{r7, lr}
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 48


 1199              	.LCFI88:
 1200              		.cfi_def_cfa_offset 8
 1201              		.cfi_offset 7, -8
 1202              		.cfi_offset 14, -4
 1203 0002 86B0     		sub	sp, sp, #24
 1204              	.LCFI89:
 1205              		.cfi_def_cfa_offset 32
 1206 0004 00AF     		add	r7, sp, #0
 1207              	.LCFI90:
 1208              		.cfi_def_cfa_register 7
 1209 0006 F860     		str	r0, [r7, #12]
 1210 0008 B960     		str	r1, [r7, #8]
 1211 000a 1346     		mov	r3, r2
 1212 000c FB71     		strb	r3, [r7, #7]
1399:./rt_thread/src/ipc.c ****     rt_mailbox_t mb;
1400:./rt_thread/src/ipc.c **** 
1401:./rt_thread/src/ipc.c ****     RT_DEBUG_NOT_IN_INTERRUPT;
1402:./rt_thread/src/ipc.c **** 
1403:./rt_thread/src/ipc.c ****     /* allocate object */
1404:./rt_thread/src/ipc.c ****     mb = (rt_mailbox_t)rt_object_allocate(RT_Object_Class_MailBox, name);
 1213              		.loc 2 1404 24
 1214 000e F968     		ldr	r1, [r7, #12]
 1215 0010 0520     		movs	r0, #5
 1216 0012 FFF7FEFF 		bl	rt_object_allocate
 1217 0016 7861     		str	r0, [r7, #20]
1405:./rt_thread/src/ipc.c ****     if (mb == RT_NULL)
 1218              		.loc 2 1405 8
 1219 0018 7B69     		ldr	r3, [r7, #20]
 1220 001a 002B     		cmp	r3, #0
 1221 001c 01D1     		bne	.L56
1406:./rt_thread/src/ipc.c ****         return mb;
 1222              		.loc 2 1406 16
 1223 001e 7B69     		ldr	r3, [r7, #20]
 1224 0020 2CE0     		b	.L57
 1225              	.L56:
1407:./rt_thread/src/ipc.c **** 
1408:./rt_thread/src/ipc.c ****     /* set parent */
1409:./rt_thread/src/ipc.c ****     mb->parent.parent.flag = flag;
 1226              		.loc 2 1409 28
 1227 0022 7B69     		ldr	r3, [r7, #20]
 1228 0024 FA79     		ldrb	r2, [r7, #7]
 1229 0026 5A72     		strb	r2, [r3, #9]
1410:./rt_thread/src/ipc.c **** 
1411:./rt_thread/src/ipc.c ****     /* initialize ipc object */
1412:./rt_thread/src/ipc.c ****     rt_ipc_object_init(&(mb->parent));
 1230              		.loc 2 1412 5
 1231 0028 7B69     		ldr	r3, [r7, #20]
 1232 002a 1846     		mov	r0, r3
 1233 002c FFF7FEFF 		bl	rt_ipc_object_init
1413:./rt_thread/src/ipc.c **** 
1414:./rt_thread/src/ipc.c ****     /* initialize mailbox */
1415:./rt_thread/src/ipc.c ****     mb->size     = size;
 1234              		.loc 2 1415 18
 1235 0030 BB68     		ldr	r3, [r7, #8]
 1236 0032 9AB2     		uxth	r2, r3
 1237 0034 7B69     		ldr	r3, [r7, #20]
 1238 0036 1A84     		strh	r2, [r3, #32]	@ movhi
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 49


1416:./rt_thread/src/ipc.c ****     mb->msg_pool = (rt_ubase_t *)RT_KERNEL_MALLOC(mb->size * sizeof(rt_ubase_t));
 1239              		.loc 2 1416 34
 1240 0038 7B69     		ldr	r3, [r7, #20]
 1241 003a 1B8C     		ldrh	r3, [r3, #32]
 1242 003c 9B00     		lsls	r3, r3, #2
 1243 003e 1846     		mov	r0, r3
 1244 0040 FFF7FEFF 		bl	rt_malloc
 1245 0044 0246     		mov	r2, r0
 1246              		.loc 2 1416 18
 1247 0046 7B69     		ldr	r3, [r7, #20]
 1248 0048 DA61     		str	r2, [r3, #28]
1417:./rt_thread/src/ipc.c ****     if (mb->msg_pool == RT_NULL)
 1249              		.loc 2 1417 11
 1250 004a 7B69     		ldr	r3, [r7, #20]
 1251 004c DB69     		ldr	r3, [r3, #28]
 1252              		.loc 2 1417 8
 1253 004e 002B     		cmp	r3, #0
 1254 0050 05D1     		bne	.L58
1418:./rt_thread/src/ipc.c ****     {
1419:./rt_thread/src/ipc.c ****         /* delete mailbox object */
1420:./rt_thread/src/ipc.c ****         rt_object_delete(&(mb->parent.parent));
 1255              		.loc 2 1420 9
 1256 0052 7B69     		ldr	r3, [r7, #20]
 1257 0054 1846     		mov	r0, r3
 1258 0056 FFF7FEFF 		bl	rt_object_delete
1421:./rt_thread/src/ipc.c **** 
1422:./rt_thread/src/ipc.c ****         return RT_NULL;
 1259              		.loc 2 1422 16
 1260 005a 0023     		movs	r3, #0
 1261 005c 0EE0     		b	.L57
 1262              	.L58:
1423:./rt_thread/src/ipc.c ****     }
1424:./rt_thread/src/ipc.c ****     mb->entry      = 0;
 1263              		.loc 2 1424 20
 1264 005e 7B69     		ldr	r3, [r7, #20]
 1265 0060 0022     		movs	r2, #0
 1266 0062 5A84     		strh	r2, [r3, #34]	@ movhi
1425:./rt_thread/src/ipc.c ****     mb->in_offset  = 0;
 1267              		.loc 2 1425 20
 1268 0064 7B69     		ldr	r3, [r7, #20]
 1269 0066 0022     		movs	r2, #0
 1270 0068 9A84     		strh	r2, [r3, #36]	@ movhi
1426:./rt_thread/src/ipc.c ****     mb->out_offset = 0;
 1271              		.loc 2 1426 20
 1272 006a 7B69     		ldr	r3, [r7, #20]
 1273 006c 0022     		movs	r2, #0
 1274 006e DA84     		strh	r2, [r3, #38]	@ movhi
1427:./rt_thread/src/ipc.c **** 
1428:./rt_thread/src/ipc.c ****     /* initialize an additional list of sender suspend thread */
1429:./rt_thread/src/ipc.c ****     rt_list_init(&(mb->suspend_sender_thread));
 1275              		.loc 2 1429 5
 1276 0070 7B69     		ldr	r3, [r7, #20]
 1277 0072 2833     		adds	r3, r3, #40
 1278 0074 1846     		mov	r0, r3
 1279 0076 FFF7FEFF 		bl	rt_list_init
1430:./rt_thread/src/ipc.c **** 
1431:./rt_thread/src/ipc.c ****     return mb;
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 50


 1280              		.loc 2 1431 12
 1281 007a 7B69     		ldr	r3, [r7, #20]
 1282              	.L57:
1432:./rt_thread/src/ipc.c **** }
 1283              		.loc 2 1432 1
 1284 007c 1846     		mov	r0, r3
 1285 007e 1837     		adds	r7, r7, #24
 1286              	.LCFI91:
 1287              		.cfi_def_cfa_offset 8
 1288 0080 BD46     		mov	sp, r7
 1289              	.LCFI92:
 1290              		.cfi_def_cfa_register 13
 1291              		@ sp needed
 1292 0082 80BD     		pop	{r7, pc}
 1293              		.cfi_endproc
 1294              	.LFE29:
 1296              		.section	.text.rt_mb_delete,"ax",%progbits
 1297              		.align	1
 1298              		.global	rt_mb_delete
 1299              		.syntax unified
 1300              		.thumb
 1301              		.thumb_func
 1303              	rt_mb_delete:
 1304              	.LFB30:
1433:./rt_thread/src/ipc.c **** 
1434:./rt_thread/src/ipc.c **** /**
1435:./rt_thread/src/ipc.c ****  * This function will delete a mailbox object and release the memory
1436:./rt_thread/src/ipc.c ****  *
1437:./rt_thread/src/ipc.c ****  * @param mb the mailbox object
1438:./rt_thread/src/ipc.c ****  *
1439:./rt_thread/src/ipc.c ****  * @return the error code
1440:./rt_thread/src/ipc.c ****  */
1441:./rt_thread/src/ipc.c **** rt_err_t rt_mb_delete(rt_mailbox_t mb)
1442:./rt_thread/src/ipc.c **** {
 1305              		.loc 2 1442 1
 1306              		.cfi_startproc
 1307              		@ args = 0, pretend = 0, frame = 8
 1308              		@ frame_needed = 1, uses_anonymous_args = 0
 1309 0000 80B5     		push	{r7, lr}
 1310              	.LCFI93:
 1311              		.cfi_def_cfa_offset 8
 1312              		.cfi_offset 7, -8
 1313              		.cfi_offset 14, -4
 1314 0002 82B0     		sub	sp, sp, #8
 1315              	.LCFI94:
 1316              		.cfi_def_cfa_offset 16
 1317 0004 00AF     		add	r7, sp, #0
 1318              	.LCFI95:
 1319              		.cfi_def_cfa_register 7
 1320 0006 7860     		str	r0, [r7, #4]
1443:./rt_thread/src/ipc.c ****     RT_DEBUG_NOT_IN_INTERRUPT;
1444:./rt_thread/src/ipc.c **** 
1445:./rt_thread/src/ipc.c ****     /* parameter check */
1446:./rt_thread/src/ipc.c ****     RT_ASSERT(mb != RT_NULL);
1447:./rt_thread/src/ipc.c ****     RT_ASSERT(rt_object_get_type(&mb->parent.parent) == RT_Object_Class_MailBox);
1448:./rt_thread/src/ipc.c ****     RT_ASSERT(rt_object_is_systemobject(&mb->parent.parent) == RT_FALSE);
1449:./rt_thread/src/ipc.c **** 
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 51


1450:./rt_thread/src/ipc.c ****     /* resume all suspended thread */
1451:./rt_thread/src/ipc.c ****     rt_ipc_list_resume_all(&(mb->parent.suspend_thread));
 1321              		.loc 2 1451 5
 1322 0008 7B68     		ldr	r3, [r7, #4]
 1323 000a 1433     		adds	r3, r3, #20
 1324 000c 1846     		mov	r0, r3
 1325 000e FFF7FEFF 		bl	rt_ipc_list_resume_all
1452:./rt_thread/src/ipc.c **** 
1453:./rt_thread/src/ipc.c ****     /* also resume all mailbox private suspended thread */
1454:./rt_thread/src/ipc.c ****     rt_ipc_list_resume_all(&(mb->suspend_sender_thread));
 1326              		.loc 2 1454 5
 1327 0012 7B68     		ldr	r3, [r7, #4]
 1328 0014 2833     		adds	r3, r3, #40
 1329 0016 1846     		mov	r0, r3
 1330 0018 FFF7FEFF 		bl	rt_ipc_list_resume_all
1455:./rt_thread/src/ipc.c **** 
1456:./rt_thread/src/ipc.c ****     /* free mailbox pool */
1457:./rt_thread/src/ipc.c ****     RT_KERNEL_FREE(mb->msg_pool);
 1331              		.loc 2 1457 5
 1332 001c 7B68     		ldr	r3, [r7, #4]
 1333 001e DB69     		ldr	r3, [r3, #28]
 1334 0020 1846     		mov	r0, r3
 1335 0022 FFF7FEFF 		bl	rt_free
1458:./rt_thread/src/ipc.c **** 
1459:./rt_thread/src/ipc.c ****     /* delete mailbox object */
1460:./rt_thread/src/ipc.c ****     rt_object_delete(&(mb->parent.parent));
 1336              		.loc 2 1460 5
 1337 0026 7B68     		ldr	r3, [r7, #4]
 1338 0028 1846     		mov	r0, r3
 1339 002a FFF7FEFF 		bl	rt_object_delete
1461:./rt_thread/src/ipc.c **** 
1462:./rt_thread/src/ipc.c ****     return RT_EOK;
 1340              		.loc 2 1462 12
 1341 002e 0023     		movs	r3, #0
1463:./rt_thread/src/ipc.c **** }
 1342              		.loc 2 1463 1
 1343 0030 1846     		mov	r0, r3
 1344 0032 0837     		adds	r7, r7, #8
 1345              	.LCFI96:
 1346              		.cfi_def_cfa_offset 8
 1347 0034 BD46     		mov	sp, r7
 1348              	.LCFI97:
 1349              		.cfi_def_cfa_register 13
 1350              		@ sp needed
 1351 0036 80BD     		pop	{r7, pc}
 1352              		.cfi_endproc
 1353              	.LFE30:
 1355              		.section	.text.rt_mb_send_wait,"ax",%progbits
 1356              		.align	1
 1357              		.global	rt_mb_send_wait
 1358              		.syntax unified
 1359              		.thumb
 1360              		.thumb_func
 1362              	rt_mb_send_wait:
 1363              	.LFB31:
1464:./rt_thread/src/ipc.c **** #endif
1465:./rt_thread/src/ipc.c **** 
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 52


1466:./rt_thread/src/ipc.c **** /**
1467:./rt_thread/src/ipc.c ****  * This function will send a mail to mailbox object. If the mailbox is full,
1468:./rt_thread/src/ipc.c ****  * current thread will be suspended until timeout.
1469:./rt_thread/src/ipc.c ****  *
1470:./rt_thread/src/ipc.c ****  * @param mb the mailbox object
1471:./rt_thread/src/ipc.c ****  * @param value the mail
1472:./rt_thread/src/ipc.c ****  * @param timeout the waiting time
1473:./rt_thread/src/ipc.c ****  *
1474:./rt_thread/src/ipc.c ****  * @return the error code
1475:./rt_thread/src/ipc.c ****  */
1476:./rt_thread/src/ipc.c **** rt_err_t rt_mb_send_wait(rt_mailbox_t mb,
1477:./rt_thread/src/ipc.c ****                          rt_ubase_t   value,
1478:./rt_thread/src/ipc.c ****                          rt_int32_t   timeout)
1479:./rt_thread/src/ipc.c **** {
 1364              		.loc 2 1479 1
 1365              		.cfi_startproc
 1366              		@ args = 0, pretend = 0, frame = 24
 1367              		@ frame_needed = 1, uses_anonymous_args = 0
 1368 0000 90B5     		push	{r4, r7, lr}
 1369              	.LCFI98:
 1370              		.cfi_def_cfa_offset 12
 1371              		.cfi_offset 4, -12
 1372              		.cfi_offset 7, -8
 1373              		.cfi_offset 14, -4
 1374 0002 87B0     		sub	sp, sp, #28
 1375              	.LCFI99:
 1376              		.cfi_def_cfa_offset 40
 1377 0004 00AF     		add	r7, sp, #0
 1378              	.LCFI100:
 1379              		.cfi_def_cfa_register 7
 1380 0006 F860     		str	r0, [r7, #12]
 1381 0008 B960     		str	r1, [r7, #8]
 1382 000a 7A60     		str	r2, [r7, #4]
1480:./rt_thread/src/ipc.c ****     struct rt_thread *thread;
1481:./rt_thread/src/ipc.c ****     register rt_ubase_t temp;
1482:./rt_thread/src/ipc.c ****     rt_uint32_t tick_delta;
1483:./rt_thread/src/ipc.c **** 
1484:./rt_thread/src/ipc.c ****     /* parameter check */
1485:./rt_thread/src/ipc.c ****     RT_ASSERT(mb != RT_NULL);
1486:./rt_thread/src/ipc.c ****     RT_ASSERT(rt_object_get_type(&mb->parent.parent) == RT_Object_Class_MailBox);
1487:./rt_thread/src/ipc.c **** 
1488:./rt_thread/src/ipc.c ****     /* initialize delta tick */
1489:./rt_thread/src/ipc.c ****     tick_delta = 0;
 1383              		.loc 2 1489 16
 1384 000c 0023     		movs	r3, #0
 1385 000e 7B61     		str	r3, [r7, #20]
1490:./rt_thread/src/ipc.c ****     /* get current thread */
1491:./rt_thread/src/ipc.c ****     thread = rt_thread_self();
 1386              		.loc 2 1491 14
 1387 0010 FFF7FEFF 		bl	rt_thread_self
 1388 0014 3861     		str	r0, [r7, #16]
1492:./rt_thread/src/ipc.c **** 
1493:./rt_thread/src/ipc.c ****     RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(mb->parent.parent)));
1494:./rt_thread/src/ipc.c **** 
1495:./rt_thread/src/ipc.c ****     /* disable interrupt */
1496:./rt_thread/src/ipc.c ****     temp = rt_hw_interrupt_disable();
 1389              		.loc 2 1496 12
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 53


 1390 0016 FFF7FEFF 		bl	rt_hw_interrupt_disable
 1391 001a 0346     		mov	r3, r0
 1392              		.loc 2 1496 10
 1393 001c 1C46     		mov	r4, r3
1497:./rt_thread/src/ipc.c **** 
1498:./rt_thread/src/ipc.c ****     /* for non-blocking call */
1499:./rt_thread/src/ipc.c ****     if (mb->entry == mb->size && timeout == 0)
 1394              		.loc 2 1499 11
 1395 001e FB68     		ldr	r3, [r7, #12]
 1396 0020 5A8C     		ldrh	r2, [r3, #34]
 1397              		.loc 2 1499 24
 1398 0022 FB68     		ldr	r3, [r7, #12]
 1399 0024 1B8C     		ldrh	r3, [r3, #32]
 1400              		.loc 2 1499 8
 1401 0026 9A42     		cmp	r2, r3
 1402 0028 55D1     		bne	.L64
 1403              		.loc 2 1499 42 discriminator 1
 1404 002a 7B68     		ldr	r3, [r7, #4]
 1405              		.loc 2 1499 31 discriminator 1
 1406 002c 002B     		cmp	r3, #0
 1407 002e 52D1     		bne	.L64
1500:./rt_thread/src/ipc.c ****     {
1501:./rt_thread/src/ipc.c ****         rt_hw_interrupt_enable(temp);
 1408              		.loc 2 1501 9
 1409 0030 2346     		mov	r3, r4
 1410 0032 1846     		mov	r0, r3
 1411 0034 FFF7FEFF 		bl	rt_hw_interrupt_enable
1502:./rt_thread/src/ipc.c **** 
1503:./rt_thread/src/ipc.c ****         return -RT_EFULL;
 1412              		.loc 2 1503 16
 1413 0038 6FF00203 		mvn	r3, #2
 1414 003c 96E0     		b	.L63
 1415              	.L68:
1504:./rt_thread/src/ipc.c ****     }
1505:./rt_thread/src/ipc.c **** 
1506:./rt_thread/src/ipc.c ****     /* mailbox is full */
1507:./rt_thread/src/ipc.c ****     while (mb->entry == mb->size)
1508:./rt_thread/src/ipc.c ****     {
1509:./rt_thread/src/ipc.c ****         /* reset error number in thread */
1510:./rt_thread/src/ipc.c ****         thread->error = RT_EOK;
 1416              		.loc 2 1510 23
 1417 003e 3B69     		ldr	r3, [r7, #16]
 1418 0040 0022     		movs	r2, #0
 1419 0042 1A63     		str	r2, [r3, #48]
1511:./rt_thread/src/ipc.c **** 
1512:./rt_thread/src/ipc.c ****         /* no waiting, return timeout */
1513:./rt_thread/src/ipc.c ****         if (timeout == 0)
 1420              		.loc 2 1513 21
 1421 0044 7B68     		ldr	r3, [r7, #4]
 1422              		.loc 2 1513 12
 1423 0046 002B     		cmp	r3, #0
 1424 0048 06D1     		bne	.L65
1514:./rt_thread/src/ipc.c ****         {
1515:./rt_thread/src/ipc.c ****             /* enable interrupt */
1516:./rt_thread/src/ipc.c ****             rt_hw_interrupt_enable(temp);
 1425              		.loc 2 1516 13
 1426 004a 2346     		mov	r3, r4
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 54


 1427 004c 1846     		mov	r0, r3
 1428 004e FFF7FEFF 		bl	rt_hw_interrupt_enable
1517:./rt_thread/src/ipc.c **** 
1518:./rt_thread/src/ipc.c ****             return -RT_EFULL;
 1429              		.loc 2 1518 20
 1430 0052 6FF00203 		mvn	r3, #2
 1431 0056 89E0     		b	.L63
 1432              	.L65:
1519:./rt_thread/src/ipc.c ****         }
1520:./rt_thread/src/ipc.c **** 
1521:./rt_thread/src/ipc.c ****         RT_DEBUG_IN_THREAD_CONTEXT;
1522:./rt_thread/src/ipc.c ****         /* suspend current thread */
1523:./rt_thread/src/ipc.c ****         rt_ipc_list_suspend(&(mb->suspend_sender_thread),
 1433              		.loc 2 1523 9
 1434 0058 FB68     		ldr	r3, [r7, #12]
 1435 005a 03F12800 		add	r0, r3, #40
 1436 005e FB68     		ldr	r3, [r7, #12]
 1437 0060 5B7A     		ldrb	r3, [r3, #9]	@ zero_extendqisi2
 1438 0062 1A46     		mov	r2, r3
 1439 0064 3969     		ldr	r1, [r7, #16]
 1440 0066 FFF7FEFF 		bl	rt_ipc_list_suspend
1524:./rt_thread/src/ipc.c ****                             thread,
1525:./rt_thread/src/ipc.c ****                             mb->parent.parent.flag);
1526:./rt_thread/src/ipc.c **** 
1527:./rt_thread/src/ipc.c ****         /* has waiting time, start thread timer */
1528:./rt_thread/src/ipc.c ****         if (timeout > 0)
 1441              		.loc 2 1528 21
 1442 006a 7B68     		ldr	r3, [r7, #4]
 1443              		.loc 2 1528 12
 1444 006c 002B     		cmp	r3, #0
 1445 006e 0EDD     		ble	.L66
1529:./rt_thread/src/ipc.c ****         {
1530:./rt_thread/src/ipc.c ****             /* get the start tick of timer */
1531:./rt_thread/src/ipc.c ****             tick_delta = rt_tick_get();
 1446              		.loc 2 1531 26
 1447 0070 FFF7FEFF 		bl	rt_tick_get
 1448 0074 7861     		str	r0, [r7, #20]
1532:./rt_thread/src/ipc.c **** 
1533:./rt_thread/src/ipc.c ****             RT_DEBUG_LOG(RT_DEBUG_IPC, ("mb_send_wait: start timer of thread:%s\n",
1534:./rt_thread/src/ipc.c ****                                         thread->name));
1535:./rt_thread/src/ipc.c **** 
1536:./rt_thread/src/ipc.c ****             /* reset the timeout of thread timer and start it */
1537:./rt_thread/src/ipc.c ****             rt_timer_control(&(thread->thread_timer),
 1449              		.loc 2 1537 13
 1450 0076 3B69     		ldr	r3, [r7, #16]
 1451 0078 4433     		adds	r3, r3, #68
 1452 007a 3A1D     		adds	r2, r7, #4
 1453 007c 0021     		movs	r1, #0
 1454 007e 1846     		mov	r0, r3
 1455 0080 FFF7FEFF 		bl	rt_timer_control
1538:./rt_thread/src/ipc.c ****                              RT_TIMER_CTRL_SET_TIME,
1539:./rt_thread/src/ipc.c ****                              &timeout);
1540:./rt_thread/src/ipc.c ****             rt_timer_start(&(thread->thread_timer));
 1456              		.loc 2 1540 13
 1457 0084 3B69     		ldr	r3, [r7, #16]
 1458 0086 4433     		adds	r3, r3, #68
 1459 0088 1846     		mov	r0, r3
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 55


 1460 008a FFF7FEFF 		bl	rt_timer_start
 1461              	.L66:
1541:./rt_thread/src/ipc.c ****         }
1542:./rt_thread/src/ipc.c **** 
1543:./rt_thread/src/ipc.c ****         /* enable interrupt */
1544:./rt_thread/src/ipc.c ****         rt_hw_interrupt_enable(temp);
 1462              		.loc 2 1544 9
 1463 008e 2346     		mov	r3, r4
 1464 0090 1846     		mov	r0, r3
 1465 0092 FFF7FEFF 		bl	rt_hw_interrupt_enable
1545:./rt_thread/src/ipc.c **** 
1546:./rt_thread/src/ipc.c ****         /* re-schedule */
1547:./rt_thread/src/ipc.c ****         rt_schedule();
 1466              		.loc 2 1547 9
 1467 0096 FFF7FEFF 		bl	rt_schedule
1548:./rt_thread/src/ipc.c **** 
1549:./rt_thread/src/ipc.c ****         /* resume from suspend state */
1550:./rt_thread/src/ipc.c ****         if (thread->error != RT_EOK)
 1468              		.loc 2 1550 19
 1469 009a 3B69     		ldr	r3, [r7, #16]
 1470 009c 1B6B     		ldr	r3, [r3, #48]
 1471              		.loc 2 1550 12
 1472 009e 002B     		cmp	r3, #0
 1473 00a0 02D0     		beq	.L67
1551:./rt_thread/src/ipc.c ****         {
1552:./rt_thread/src/ipc.c ****             /* return error */
1553:./rt_thread/src/ipc.c ****             return thread->error;
 1474              		.loc 2 1553 26
 1475 00a2 3B69     		ldr	r3, [r7, #16]
 1476 00a4 1B6B     		ldr	r3, [r3, #48]
 1477 00a6 61E0     		b	.L63
 1478              	.L67:
1554:./rt_thread/src/ipc.c ****         }
1555:./rt_thread/src/ipc.c **** 
1556:./rt_thread/src/ipc.c ****         /* disable interrupt */
1557:./rt_thread/src/ipc.c ****         temp = rt_hw_interrupt_disable();
 1479              		.loc 2 1557 16
 1480 00a8 FFF7FEFF 		bl	rt_hw_interrupt_disable
 1481 00ac 0346     		mov	r3, r0
 1482              		.loc 2 1557 14
 1483 00ae 1C46     		mov	r4, r3
1558:./rt_thread/src/ipc.c **** 
1559:./rt_thread/src/ipc.c ****         /* if it's not waiting forever and then re-calculate timeout tick */
1560:./rt_thread/src/ipc.c ****         if (timeout > 0)
 1484              		.loc 2 1560 21
 1485 00b0 7B68     		ldr	r3, [r7, #4]
 1486              		.loc 2 1560 12
 1487 00b2 002B     		cmp	r3, #0
 1488 00b4 0FDD     		ble	.L64
1561:./rt_thread/src/ipc.c ****         {
1562:./rt_thread/src/ipc.c ****             tick_delta = rt_tick_get() - tick_delta;
 1489              		.loc 2 1562 26
 1490 00b6 FFF7FEFF 		bl	rt_tick_get
 1491 00ba 0246     		mov	r2, r0
 1492              		.loc 2 1562 24
 1493 00bc 7B69     		ldr	r3, [r7, #20]
 1494 00be D31A     		subs	r3, r2, r3
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 56


 1495 00c0 7B61     		str	r3, [r7, #20]
1563:./rt_thread/src/ipc.c ****             timeout -= tick_delta;
 1496              		.loc 2 1563 21
 1497 00c2 7B68     		ldr	r3, [r7, #4]
 1498 00c4 1A46     		mov	r2, r3
 1499 00c6 7B69     		ldr	r3, [r7, #20]
 1500 00c8 D31A     		subs	r3, r2, r3
 1501 00ca 7B60     		str	r3, [r7, #4]
1564:./rt_thread/src/ipc.c ****             if (timeout < 0)
 1502              		.loc 2 1564 25
 1503 00cc 7B68     		ldr	r3, [r7, #4]
 1504              		.loc 2 1564 16
 1505 00ce 002B     		cmp	r3, #0
 1506 00d0 01DA     		bge	.L64
1565:./rt_thread/src/ipc.c ****                 timeout = 0;
 1507              		.loc 2 1565 25
 1508 00d2 0023     		movs	r3, #0
 1509 00d4 7B60     		str	r3, [r7, #4]
 1510              	.L64:
1507:./rt_thread/src/ipc.c ****     {
 1511              		.loc 2 1507 14
 1512 00d6 FB68     		ldr	r3, [r7, #12]
 1513 00d8 5A8C     		ldrh	r2, [r3, #34]
1507:./rt_thread/src/ipc.c ****     {
 1514              		.loc 2 1507 27
 1515 00da FB68     		ldr	r3, [r7, #12]
 1516 00dc 1B8C     		ldrh	r3, [r3, #32]
1507:./rt_thread/src/ipc.c ****     {
 1517              		.loc 2 1507 11
 1518 00de 9A42     		cmp	r2, r3
 1519 00e0 ADD0     		beq	.L68
1566:./rt_thread/src/ipc.c ****         }
1567:./rt_thread/src/ipc.c ****     }
1568:./rt_thread/src/ipc.c **** 
1569:./rt_thread/src/ipc.c ****     /* set ptr */
1570:./rt_thread/src/ipc.c ****     mb->msg_pool[mb->in_offset] = value;
 1520              		.loc 2 1570 7
 1521 00e2 FB68     		ldr	r3, [r7, #12]
 1522 00e4 DA69     		ldr	r2, [r3, #28]
 1523              		.loc 2 1570 20
 1524 00e6 FB68     		ldr	r3, [r7, #12]
 1525 00e8 9B8C     		ldrh	r3, [r3, #36]
 1526              		.loc 2 1570 17
 1527 00ea 9B00     		lsls	r3, r3, #2
 1528 00ec 1344     		add	r3, r3, r2
 1529              		.loc 2 1570 33
 1530 00ee BA68     		ldr	r2, [r7, #8]
 1531 00f0 1A60     		str	r2, [r3]
1571:./rt_thread/src/ipc.c ****     /* increase input offset */
1572:./rt_thread/src/ipc.c ****     ++ mb->in_offset;
 1532              		.loc 2 1572 10
 1533 00f2 FB68     		ldr	r3, [r7, #12]
 1534 00f4 9B8C     		ldrh	r3, [r3, #36]
 1535              		.loc 2 1572 5
 1536 00f6 0133     		adds	r3, r3, #1
 1537 00f8 9AB2     		uxth	r2, r3
 1538 00fa FB68     		ldr	r3, [r7, #12]
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 57


 1539 00fc 9A84     		strh	r2, [r3, #36]	@ movhi
1573:./rt_thread/src/ipc.c ****     if (mb->in_offset >= mb->size)
 1540              		.loc 2 1573 11
 1541 00fe FB68     		ldr	r3, [r7, #12]
 1542 0100 9A8C     		ldrh	r2, [r3, #36]
 1543              		.loc 2 1573 28
 1544 0102 FB68     		ldr	r3, [r7, #12]
 1545 0104 1B8C     		ldrh	r3, [r3, #32]
 1546              		.loc 2 1573 8
 1547 0106 9A42     		cmp	r2, r3
 1548 0108 02D3     		bcc	.L69
1574:./rt_thread/src/ipc.c ****         mb->in_offset = 0;
 1549              		.loc 2 1574 23
 1550 010a FB68     		ldr	r3, [r7, #12]
 1551 010c 0022     		movs	r2, #0
 1552 010e 9A84     		strh	r2, [r3, #36]	@ movhi
 1553              	.L69:
1575:./rt_thread/src/ipc.c **** 
1576:./rt_thread/src/ipc.c ****     if(mb->entry < RT_MB_ENTRY_MAX)
 1554              		.loc 2 1576 10
 1555 0110 FB68     		ldr	r3, [r7, #12]
 1556 0112 5B8C     		ldrh	r3, [r3, #34]
 1557              		.loc 2 1576 7
 1558 0114 4FF6FF72 		movw	r2, #65535
 1559 0118 9342     		cmp	r3, r2
 1560 011a 0ED0     		beq	.L70
1577:./rt_thread/src/ipc.c ****     {
1578:./rt_thread/src/ipc.c ****         /* increase message entry */
1579:./rt_thread/src/ipc.c ****         mb->entry ++;
 1561              		.loc 2 1579 11
 1562 011c FB68     		ldr	r3, [r7, #12]
 1563 011e 5B8C     		ldrh	r3, [r3, #34]
 1564              		.loc 2 1579 19
 1565 0120 0133     		adds	r3, r3, #1
 1566 0122 9AB2     		uxth	r2, r3
 1567 0124 FB68     		ldr	r3, [r7, #12]
 1568 0126 5A84     		strh	r2, [r3, #34]	@ movhi
1580:./rt_thread/src/ipc.c ****     }
1581:./rt_thread/src/ipc.c ****     else
1582:./rt_thread/src/ipc.c ****     {
1583:./rt_thread/src/ipc.c ****         rt_hw_interrupt_enable(temp); /* enable interrupt */
1584:./rt_thread/src/ipc.c ****         return -RT_EFULL; /* value overflowed */
1585:./rt_thread/src/ipc.c ****     }
1586:./rt_thread/src/ipc.c **** 
1587:./rt_thread/src/ipc.c ****     /* resume suspended thread */
1588:./rt_thread/src/ipc.c ****     if (!rt_list_isempty(&mb->parent.suspend_thread))
 1569              		.loc 2 1588 26
 1570 0128 FB68     		ldr	r3, [r7, #12]
 1571 012a 1433     		adds	r3, r3, #20
 1572              		.loc 2 1588 10
 1573 012c 1846     		mov	r0, r3
 1574 012e FFF7FEFF 		bl	rt_list_isempty
 1575 0132 0346     		mov	r3, r0
 1576              		.loc 2 1588 8
 1577 0134 002B     		cmp	r3, #0
 1578 0136 14D1     		bne	.L72
 1579 0138 06E0     		b	.L73
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 58


 1580              	.L70:
1583:./rt_thread/src/ipc.c ****         return -RT_EFULL; /* value overflowed */
 1581              		.loc 2 1583 9
 1582 013a 2346     		mov	r3, r4
 1583 013c 1846     		mov	r0, r3
 1584 013e FFF7FEFF 		bl	rt_hw_interrupt_enable
1584:./rt_thread/src/ipc.c ****     }
 1585              		.loc 2 1584 16
 1586 0142 6FF00203 		mvn	r3, #2
 1587 0146 11E0     		b	.L63
 1588              	.L73:
1589:./rt_thread/src/ipc.c ****     {
1590:./rt_thread/src/ipc.c ****         rt_ipc_list_resume(&(mb->parent.suspend_thread));
 1589              		.loc 2 1590 9
 1590 0148 FB68     		ldr	r3, [r7, #12]
 1591 014a 1433     		adds	r3, r3, #20
 1592 014c 1846     		mov	r0, r3
 1593 014e FFF7FEFF 		bl	rt_ipc_list_resume
1591:./rt_thread/src/ipc.c **** 
1592:./rt_thread/src/ipc.c ****         /* enable interrupt */
1593:./rt_thread/src/ipc.c ****         rt_hw_interrupt_enable(temp);
 1594              		.loc 2 1593 9
 1595 0152 2346     		mov	r3, r4
 1596 0154 1846     		mov	r0, r3
 1597 0156 FFF7FEFF 		bl	rt_hw_interrupt_enable
1594:./rt_thread/src/ipc.c **** 
1595:./rt_thread/src/ipc.c ****         rt_schedule();
 1598              		.loc 2 1595 9
 1599 015a FFF7FEFF 		bl	rt_schedule
1596:./rt_thread/src/ipc.c **** 
1597:./rt_thread/src/ipc.c ****         return RT_EOK;
 1600              		.loc 2 1597 16
 1601 015e 0023     		movs	r3, #0
 1602 0160 04E0     		b	.L63
 1603              	.L72:
1598:./rt_thread/src/ipc.c ****     }
1599:./rt_thread/src/ipc.c **** 
1600:./rt_thread/src/ipc.c ****     /* enable interrupt */
1601:./rt_thread/src/ipc.c ****     rt_hw_interrupt_enable(temp);
 1604              		.loc 2 1601 5
 1605 0162 2346     		mov	r3, r4
 1606 0164 1846     		mov	r0, r3
 1607 0166 FFF7FEFF 		bl	rt_hw_interrupt_enable
1602:./rt_thread/src/ipc.c **** 
1603:./rt_thread/src/ipc.c ****     return RT_EOK;
 1608              		.loc 2 1603 12
 1609 016a 0023     		movs	r3, #0
 1610              	.L63:
1604:./rt_thread/src/ipc.c **** }
 1611              		.loc 2 1604 1
 1612 016c 1846     		mov	r0, r3
 1613 016e 1C37     		adds	r7, r7, #28
 1614              	.LCFI101:
 1615              		.cfi_def_cfa_offset 12
 1616 0170 BD46     		mov	sp, r7
 1617              	.LCFI102:
 1618              		.cfi_def_cfa_register 13
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 59


 1619              		@ sp needed
 1620 0172 90BD     		pop	{r4, r7, pc}
 1621              		.cfi_endproc
 1622              	.LFE31:
 1624              		.section	.text.rt_mb_send,"ax",%progbits
 1625              		.align	1
 1626              		.global	rt_mb_send
 1627              		.syntax unified
 1628              		.thumb
 1629              		.thumb_func
 1631              	rt_mb_send:
 1632              	.LFB32:
1605:./rt_thread/src/ipc.c **** 
1606:./rt_thread/src/ipc.c **** /**
1607:./rt_thread/src/ipc.c ****  * This function will send a mail to mailbox object, if there are threads
1608:./rt_thread/src/ipc.c ****  * suspended on mailbox object, it will be waked up. This function will return
1609:./rt_thread/src/ipc.c ****  * immediately, if you want blocking send, use rt_mb_send_wait instead.
1610:./rt_thread/src/ipc.c ****  *
1611:./rt_thread/src/ipc.c ****  * @param mb the mailbox object
1612:./rt_thread/src/ipc.c ****  * @param value the mail
1613:./rt_thread/src/ipc.c ****  *
1614:./rt_thread/src/ipc.c ****  * @return the error code
1615:./rt_thread/src/ipc.c ****  */
1616:./rt_thread/src/ipc.c **** rt_err_t rt_mb_send(rt_mailbox_t mb, rt_ubase_t value)
1617:./rt_thread/src/ipc.c **** {
 1633              		.loc 2 1617 1
 1634              		.cfi_startproc
 1635              		@ args = 0, pretend = 0, frame = 8
 1636              		@ frame_needed = 1, uses_anonymous_args = 0
 1637 0000 80B5     		push	{r7, lr}
 1638              	.LCFI103:
 1639              		.cfi_def_cfa_offset 8
 1640              		.cfi_offset 7, -8
 1641              		.cfi_offset 14, -4
 1642 0002 82B0     		sub	sp, sp, #8
 1643              	.LCFI104:
 1644              		.cfi_def_cfa_offset 16
 1645 0004 00AF     		add	r7, sp, #0
 1646              	.LCFI105:
 1647              		.cfi_def_cfa_register 7
 1648 0006 7860     		str	r0, [r7, #4]
 1649 0008 3960     		str	r1, [r7]
1618:./rt_thread/src/ipc.c ****     return rt_mb_send_wait(mb, value, 0);
 1650              		.loc 2 1618 12
 1651 000a 0022     		movs	r2, #0
 1652 000c 3968     		ldr	r1, [r7]
 1653 000e 7868     		ldr	r0, [r7, #4]
 1654 0010 FFF7FEFF 		bl	rt_mb_send_wait
 1655 0014 0346     		mov	r3, r0
1619:./rt_thread/src/ipc.c **** }
 1656              		.loc 2 1619 1
 1657 0016 1846     		mov	r0, r3
 1658 0018 0837     		adds	r7, r7, #8
 1659              	.LCFI106:
 1660              		.cfi_def_cfa_offset 8
 1661 001a BD46     		mov	sp, r7
 1662              	.LCFI107:
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 60


 1663              		.cfi_def_cfa_register 13
 1664              		@ sp needed
 1665 001c 80BD     		pop	{r7, pc}
 1666              		.cfi_endproc
 1667              	.LFE32:
 1669              		.section	.text.rt_mb_recv,"ax",%progbits
 1670              		.align	1
 1671              		.global	rt_mb_recv
 1672              		.syntax unified
 1673              		.thumb
 1674              		.thumb_func
 1676              	rt_mb_recv:
 1677              	.LFB33:
1620:./rt_thread/src/ipc.c **** 
1621:./rt_thread/src/ipc.c **** /**
1622:./rt_thread/src/ipc.c ****  * This function will receive a mail from mailbox object, if there is no mail
1623:./rt_thread/src/ipc.c ****  * in mailbox object, the thread shall wait for a specified time.
1624:./rt_thread/src/ipc.c ****  *
1625:./rt_thread/src/ipc.c ****  * @param mb the mailbox object
1626:./rt_thread/src/ipc.c ****  * @param value the received mail will be saved in
1627:./rt_thread/src/ipc.c ****  * @param timeout the waiting time
1628:./rt_thread/src/ipc.c ****  *
1629:./rt_thread/src/ipc.c ****  * @return the error code
1630:./rt_thread/src/ipc.c ****  */
1631:./rt_thread/src/ipc.c **** rt_err_t rt_mb_recv(rt_mailbox_t mb, rt_ubase_t *value, rt_int32_t timeout)
1632:./rt_thread/src/ipc.c **** {
 1678              		.loc 2 1632 1
 1679              		.cfi_startproc
 1680              		@ args = 0, pretend = 0, frame = 24
 1681              		@ frame_needed = 1, uses_anonymous_args = 0
 1682 0000 90B5     		push	{r4, r7, lr}
 1683              	.LCFI108:
 1684              		.cfi_def_cfa_offset 12
 1685              		.cfi_offset 4, -12
 1686              		.cfi_offset 7, -8
 1687              		.cfi_offset 14, -4
 1688 0002 87B0     		sub	sp, sp, #28
 1689              	.LCFI109:
 1690              		.cfi_def_cfa_offset 40
 1691 0004 00AF     		add	r7, sp, #0
 1692              	.LCFI110:
 1693              		.cfi_def_cfa_register 7
 1694 0006 F860     		str	r0, [r7, #12]
 1695 0008 B960     		str	r1, [r7, #8]
 1696 000a 7A60     		str	r2, [r7, #4]
1633:./rt_thread/src/ipc.c ****     struct rt_thread *thread;
1634:./rt_thread/src/ipc.c ****     register rt_ubase_t temp;
1635:./rt_thread/src/ipc.c ****     rt_uint32_t tick_delta;
1636:./rt_thread/src/ipc.c **** 
1637:./rt_thread/src/ipc.c ****     /* parameter check */
1638:./rt_thread/src/ipc.c ****     RT_ASSERT(mb != RT_NULL);
1639:./rt_thread/src/ipc.c ****     RT_ASSERT(rt_object_get_type(&mb->parent.parent) == RT_Object_Class_MailBox);
1640:./rt_thread/src/ipc.c **** 
1641:./rt_thread/src/ipc.c ****     /* initialize delta tick */
1642:./rt_thread/src/ipc.c ****     tick_delta = 0;
 1697              		.loc 2 1642 16
 1698 000c 0023     		movs	r3, #0
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 61


 1699 000e 7B61     		str	r3, [r7, #20]
1643:./rt_thread/src/ipc.c ****     /* get current thread */
1644:./rt_thread/src/ipc.c ****     thread = rt_thread_self();
 1700              		.loc 2 1644 14
 1701 0010 FFF7FEFF 		bl	rt_thread_self
 1702 0014 3861     		str	r0, [r7, #16]
1645:./rt_thread/src/ipc.c **** 
1646:./rt_thread/src/ipc.c ****     RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(mb->parent.parent)));
1647:./rt_thread/src/ipc.c **** 
1648:./rt_thread/src/ipc.c ****     /* disable interrupt */
1649:./rt_thread/src/ipc.c ****     temp = rt_hw_interrupt_disable();
 1703              		.loc 2 1649 12
 1704 0016 FFF7FEFF 		bl	rt_hw_interrupt_disable
 1705 001a 0346     		mov	r3, r0
 1706              		.loc 2 1649 10
 1707 001c 1C46     		mov	r4, r3
1650:./rt_thread/src/ipc.c **** 
1651:./rt_thread/src/ipc.c ****     /* for non-blocking call */
1652:./rt_thread/src/ipc.c ****     if (mb->entry == 0 && timeout == 0)
 1708              		.loc 2 1652 11
 1709 001e FB68     		ldr	r3, [r7, #12]
 1710 0020 5B8C     		ldrh	r3, [r3, #34]
 1711              		.loc 2 1652 8
 1712 0022 002B     		cmp	r3, #0
 1713 0024 59D1     		bne	.L79
 1714              		.loc 2 1652 35 discriminator 1
 1715 0026 7B68     		ldr	r3, [r7, #4]
 1716              		.loc 2 1652 24 discriminator 1
 1717 0028 002B     		cmp	r3, #0
 1718 002a 56D1     		bne	.L79
1653:./rt_thread/src/ipc.c ****     {
1654:./rt_thread/src/ipc.c ****         rt_hw_interrupt_enable(temp);
 1719              		.loc 2 1654 9
 1720 002c 2346     		mov	r3, r4
 1721 002e 1846     		mov	r0, r3
 1722 0030 FFF7FEFF 		bl	rt_hw_interrupt_enable
1655:./rt_thread/src/ipc.c **** 
1656:./rt_thread/src/ipc.c ****         return -RT_ETIMEOUT;
 1723              		.loc 2 1656 16
 1724 0034 6FF00103 		mvn	r3, #1
 1725 0038 8FE0     		b	.L78
 1726              	.L83:
1657:./rt_thread/src/ipc.c ****     }
1658:./rt_thread/src/ipc.c **** 
1659:./rt_thread/src/ipc.c ****     /* mailbox is empty */
1660:./rt_thread/src/ipc.c ****     while (mb->entry == 0)
1661:./rt_thread/src/ipc.c ****     {
1662:./rt_thread/src/ipc.c ****         /* reset error number in thread */
1663:./rt_thread/src/ipc.c ****         thread->error = RT_EOK;
 1727              		.loc 2 1663 23
 1728 003a 3B69     		ldr	r3, [r7, #16]
 1729 003c 0022     		movs	r2, #0
 1730 003e 1A63     		str	r2, [r3, #48]
1664:./rt_thread/src/ipc.c **** 
1665:./rt_thread/src/ipc.c ****         /* no waiting, return timeout */
1666:./rt_thread/src/ipc.c ****         if (timeout == 0)
 1731              		.loc 2 1666 21
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 62


 1732 0040 7B68     		ldr	r3, [r7, #4]
 1733              		.loc 2 1666 12
 1734 0042 002B     		cmp	r3, #0
 1735 0044 0AD1     		bne	.L80
1667:./rt_thread/src/ipc.c ****         {
1668:./rt_thread/src/ipc.c ****             /* enable interrupt */
1669:./rt_thread/src/ipc.c ****             rt_hw_interrupt_enable(temp);
 1736              		.loc 2 1669 13
 1737 0046 2346     		mov	r3, r4
 1738 0048 1846     		mov	r0, r3
 1739 004a FFF7FEFF 		bl	rt_hw_interrupt_enable
1670:./rt_thread/src/ipc.c **** 
1671:./rt_thread/src/ipc.c ****             thread->error = -RT_ETIMEOUT;
 1740              		.loc 2 1671 27
 1741 004e 3B69     		ldr	r3, [r7, #16]
 1742 0050 6FF00102 		mvn	r2, #1
 1743 0054 1A63     		str	r2, [r3, #48]
1672:./rt_thread/src/ipc.c **** 
1673:./rt_thread/src/ipc.c ****             return -RT_ETIMEOUT;
 1744              		.loc 2 1673 20
 1745 0056 6FF00103 		mvn	r3, #1
 1746 005a 7EE0     		b	.L78
 1747              	.L80:
1674:./rt_thread/src/ipc.c ****         }
1675:./rt_thread/src/ipc.c **** 
1676:./rt_thread/src/ipc.c ****         RT_DEBUG_IN_THREAD_CONTEXT;
1677:./rt_thread/src/ipc.c ****         /* suspend current thread */
1678:./rt_thread/src/ipc.c ****         rt_ipc_list_suspend(&(mb->parent.suspend_thread),
 1748              		.loc 2 1678 9
 1749 005c FB68     		ldr	r3, [r7, #12]
 1750 005e 03F11400 		add	r0, r3, #20
 1751 0062 FB68     		ldr	r3, [r7, #12]
 1752 0064 5B7A     		ldrb	r3, [r3, #9]	@ zero_extendqisi2
 1753 0066 1A46     		mov	r2, r3
 1754 0068 3969     		ldr	r1, [r7, #16]
 1755 006a FFF7FEFF 		bl	rt_ipc_list_suspend
1679:./rt_thread/src/ipc.c ****                             thread,
1680:./rt_thread/src/ipc.c ****                             mb->parent.parent.flag);
1681:./rt_thread/src/ipc.c **** 
1682:./rt_thread/src/ipc.c ****         /* has waiting time, start thread timer */
1683:./rt_thread/src/ipc.c ****         if (timeout > 0)
 1756              		.loc 2 1683 21
 1757 006e 7B68     		ldr	r3, [r7, #4]
 1758              		.loc 2 1683 12
 1759 0070 002B     		cmp	r3, #0
 1760 0072 0EDD     		ble	.L81
1684:./rt_thread/src/ipc.c ****         {
1685:./rt_thread/src/ipc.c ****             /* get the start tick of timer */
1686:./rt_thread/src/ipc.c ****             tick_delta = rt_tick_get();
 1761              		.loc 2 1686 26
 1762 0074 FFF7FEFF 		bl	rt_tick_get
 1763 0078 7861     		str	r0, [r7, #20]
1687:./rt_thread/src/ipc.c **** 
1688:./rt_thread/src/ipc.c ****             RT_DEBUG_LOG(RT_DEBUG_IPC, ("mb_recv: start timer of thread:%s\n",
1689:./rt_thread/src/ipc.c ****                                         thread->name));
1690:./rt_thread/src/ipc.c **** 
1691:./rt_thread/src/ipc.c ****             /* reset the timeout of thread timer and start it */
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 63


1692:./rt_thread/src/ipc.c ****             rt_timer_control(&(thread->thread_timer),
 1764              		.loc 2 1692 13
 1765 007a 3B69     		ldr	r3, [r7, #16]
 1766 007c 4433     		adds	r3, r3, #68
 1767 007e 3A1D     		adds	r2, r7, #4
 1768 0080 0021     		movs	r1, #0
 1769 0082 1846     		mov	r0, r3
 1770 0084 FFF7FEFF 		bl	rt_timer_control
1693:./rt_thread/src/ipc.c ****                              RT_TIMER_CTRL_SET_TIME,
1694:./rt_thread/src/ipc.c ****                              &timeout);
1695:./rt_thread/src/ipc.c ****             rt_timer_start(&(thread->thread_timer));
 1771              		.loc 2 1695 13
 1772 0088 3B69     		ldr	r3, [r7, #16]
 1773 008a 4433     		adds	r3, r3, #68
 1774 008c 1846     		mov	r0, r3
 1775 008e FFF7FEFF 		bl	rt_timer_start
 1776              	.L81:
1696:./rt_thread/src/ipc.c ****         }
1697:./rt_thread/src/ipc.c **** 
1698:./rt_thread/src/ipc.c ****         /* enable interrupt */
1699:./rt_thread/src/ipc.c ****         rt_hw_interrupt_enable(temp);
 1777              		.loc 2 1699 9
 1778 0092 2346     		mov	r3, r4
 1779 0094 1846     		mov	r0, r3
 1780 0096 FFF7FEFF 		bl	rt_hw_interrupt_enable
1700:./rt_thread/src/ipc.c **** 
1701:./rt_thread/src/ipc.c ****         /* re-schedule */
1702:./rt_thread/src/ipc.c ****         rt_schedule();
 1781              		.loc 2 1702 9
 1782 009a FFF7FEFF 		bl	rt_schedule
1703:./rt_thread/src/ipc.c **** 
1704:./rt_thread/src/ipc.c ****         /* resume from suspend state */
1705:./rt_thread/src/ipc.c ****         if (thread->error != RT_EOK)
 1783              		.loc 2 1705 19
 1784 009e 3B69     		ldr	r3, [r7, #16]
 1785 00a0 1B6B     		ldr	r3, [r3, #48]
 1786              		.loc 2 1705 12
 1787 00a2 002B     		cmp	r3, #0
 1788 00a4 02D0     		beq	.L82
1706:./rt_thread/src/ipc.c ****         {
1707:./rt_thread/src/ipc.c ****             /* return error */
1708:./rt_thread/src/ipc.c ****             return thread->error;
 1789              		.loc 2 1708 26
 1790 00a6 3B69     		ldr	r3, [r7, #16]
 1791 00a8 1B6B     		ldr	r3, [r3, #48]
 1792 00aa 56E0     		b	.L78
 1793              	.L82:
1709:./rt_thread/src/ipc.c ****         }
1710:./rt_thread/src/ipc.c **** 
1711:./rt_thread/src/ipc.c ****         /* disable interrupt */
1712:./rt_thread/src/ipc.c ****         temp = rt_hw_interrupt_disable();
 1794              		.loc 2 1712 16
 1795 00ac FFF7FEFF 		bl	rt_hw_interrupt_disable
 1796 00b0 0346     		mov	r3, r0
 1797              		.loc 2 1712 14
 1798 00b2 1C46     		mov	r4, r3
1713:./rt_thread/src/ipc.c **** 
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 64


1714:./rt_thread/src/ipc.c ****         /* if it's not waiting forever and then re-calculate timeout tick */
1715:./rt_thread/src/ipc.c ****         if (timeout > 0)
 1799              		.loc 2 1715 21
 1800 00b4 7B68     		ldr	r3, [r7, #4]
 1801              		.loc 2 1715 12
 1802 00b6 002B     		cmp	r3, #0
 1803 00b8 0FDD     		ble	.L79
1716:./rt_thread/src/ipc.c ****         {
1717:./rt_thread/src/ipc.c ****             tick_delta = rt_tick_get() - tick_delta;
 1804              		.loc 2 1717 26
 1805 00ba FFF7FEFF 		bl	rt_tick_get
 1806 00be 0246     		mov	r2, r0
 1807              		.loc 2 1717 24
 1808 00c0 7B69     		ldr	r3, [r7, #20]
 1809 00c2 D31A     		subs	r3, r2, r3
 1810 00c4 7B61     		str	r3, [r7, #20]
1718:./rt_thread/src/ipc.c ****             timeout -= tick_delta;
 1811              		.loc 2 1718 21
 1812 00c6 7B68     		ldr	r3, [r7, #4]
 1813 00c8 1A46     		mov	r2, r3
 1814 00ca 7B69     		ldr	r3, [r7, #20]
 1815 00cc D31A     		subs	r3, r2, r3
 1816 00ce 7B60     		str	r3, [r7, #4]
1719:./rt_thread/src/ipc.c ****             if (timeout < 0)
 1817              		.loc 2 1719 25
 1818 00d0 7B68     		ldr	r3, [r7, #4]
 1819              		.loc 2 1719 16
 1820 00d2 002B     		cmp	r3, #0
 1821 00d4 01DA     		bge	.L79
1720:./rt_thread/src/ipc.c ****                 timeout = 0;
 1822              		.loc 2 1720 25
 1823 00d6 0023     		movs	r3, #0
 1824 00d8 7B60     		str	r3, [r7, #4]
 1825              	.L79:
1660:./rt_thread/src/ipc.c ****     {
 1826              		.loc 2 1660 14
 1827 00da FB68     		ldr	r3, [r7, #12]
 1828 00dc 5B8C     		ldrh	r3, [r3, #34]
1660:./rt_thread/src/ipc.c ****     {
 1829              		.loc 2 1660 11
 1830 00de 002B     		cmp	r3, #0
 1831 00e0 ABD0     		beq	.L83
1721:./rt_thread/src/ipc.c ****         }
1722:./rt_thread/src/ipc.c ****     }
1723:./rt_thread/src/ipc.c **** 
1724:./rt_thread/src/ipc.c ****     /* fill ptr */
1725:./rt_thread/src/ipc.c ****     *value = mb->msg_pool[mb->out_offset];
 1832              		.loc 2 1725 16
 1833 00e2 FB68     		ldr	r3, [r7, #12]
 1834 00e4 DA69     		ldr	r2, [r3, #28]
 1835              		.loc 2 1725 29
 1836 00e6 FB68     		ldr	r3, [r7, #12]
 1837 00e8 DB8C     		ldrh	r3, [r3, #38]
 1838              		.loc 2 1725 26
 1839 00ea 9B00     		lsls	r3, r3, #2
 1840 00ec 1344     		add	r3, r3, r2
 1841 00ee 1A68     		ldr	r2, [r3]
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 65


 1842              		.loc 2 1725 12
 1843 00f0 BB68     		ldr	r3, [r7, #8]
 1844 00f2 1A60     		str	r2, [r3]
1726:./rt_thread/src/ipc.c **** 
1727:./rt_thread/src/ipc.c ****     /* increase output offset */
1728:./rt_thread/src/ipc.c ****     ++ mb->out_offset;
 1845              		.loc 2 1728 10
 1846 00f4 FB68     		ldr	r3, [r7, #12]
 1847 00f6 DB8C     		ldrh	r3, [r3, #38]
 1848              		.loc 2 1728 5
 1849 00f8 0133     		adds	r3, r3, #1
 1850 00fa 9AB2     		uxth	r2, r3
 1851 00fc FB68     		ldr	r3, [r7, #12]
 1852 00fe DA84     		strh	r2, [r3, #38]	@ movhi
1729:./rt_thread/src/ipc.c ****     if (mb->out_offset >= mb->size)
 1853              		.loc 2 1729 11
 1854 0100 FB68     		ldr	r3, [r7, #12]
 1855 0102 DA8C     		ldrh	r2, [r3, #38]
 1856              		.loc 2 1729 29
 1857 0104 FB68     		ldr	r3, [r7, #12]
 1858 0106 1B8C     		ldrh	r3, [r3, #32]
 1859              		.loc 2 1729 8
 1860 0108 9A42     		cmp	r2, r3
 1861 010a 02D3     		bcc	.L84
1730:./rt_thread/src/ipc.c ****         mb->out_offset = 0;
 1862              		.loc 2 1730 24
 1863 010c FB68     		ldr	r3, [r7, #12]
 1864 010e 0022     		movs	r2, #0
 1865 0110 DA84     		strh	r2, [r3, #38]	@ movhi
 1866              	.L84:
1731:./rt_thread/src/ipc.c **** 
1732:./rt_thread/src/ipc.c ****     /* decrease message entry */
1733:./rt_thread/src/ipc.c ****     if(mb->entry > 0)
 1867              		.loc 2 1733 10
 1868 0112 FB68     		ldr	r3, [r7, #12]
 1869 0114 5B8C     		ldrh	r3, [r3, #34]
 1870              		.loc 2 1733 7
 1871 0116 002B     		cmp	r3, #0
 1872 0118 05D0     		beq	.L85
1734:./rt_thread/src/ipc.c ****     {
1735:./rt_thread/src/ipc.c ****         mb->entry --;
 1873              		.loc 2 1735 11
 1874 011a FB68     		ldr	r3, [r7, #12]
 1875 011c 5B8C     		ldrh	r3, [r3, #34]
 1876              		.loc 2 1735 19
 1877 011e 013B     		subs	r3, r3, #1
 1878 0120 9AB2     		uxth	r2, r3
 1879 0122 FB68     		ldr	r3, [r7, #12]
 1880 0124 5A84     		strh	r2, [r3, #34]	@ movhi
 1881              	.L85:
1736:./rt_thread/src/ipc.c ****     }
1737:./rt_thread/src/ipc.c **** 
1738:./rt_thread/src/ipc.c ****     /* resume suspended thread */
1739:./rt_thread/src/ipc.c ****     if (!rt_list_isempty(&(mb->suspend_sender_thread)))
 1882              		.loc 2 1739 26
 1883 0126 FB68     		ldr	r3, [r7, #12]
 1884 0128 2833     		adds	r3, r3, #40
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 66


 1885              		.loc 2 1739 10
 1886 012a 1846     		mov	r0, r3
 1887 012c FFF7FEFF 		bl	rt_list_isempty
 1888 0130 0346     		mov	r3, r0
 1889              		.loc 2 1739 8
 1890 0132 002B     		cmp	r3, #0
 1891 0134 0CD1     		bne	.L86
1740:./rt_thread/src/ipc.c ****     {
1741:./rt_thread/src/ipc.c ****         rt_ipc_list_resume(&(mb->suspend_sender_thread));
 1892              		.loc 2 1741 9
 1893 0136 FB68     		ldr	r3, [r7, #12]
 1894 0138 2833     		adds	r3, r3, #40
 1895 013a 1846     		mov	r0, r3
 1896 013c FFF7FEFF 		bl	rt_ipc_list_resume
1742:./rt_thread/src/ipc.c **** 
1743:./rt_thread/src/ipc.c ****         /* enable interrupt */
1744:./rt_thread/src/ipc.c ****         rt_hw_interrupt_enable(temp);
 1897              		.loc 2 1744 9
 1898 0140 2346     		mov	r3, r4
 1899 0142 1846     		mov	r0, r3
 1900 0144 FFF7FEFF 		bl	rt_hw_interrupt_enable
1745:./rt_thread/src/ipc.c **** 
1746:./rt_thread/src/ipc.c ****         RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(mb->parent.parent)));
1747:./rt_thread/src/ipc.c **** 
1748:./rt_thread/src/ipc.c ****         rt_schedule();
 1901              		.loc 2 1748 9
 1902 0148 FFF7FEFF 		bl	rt_schedule
1749:./rt_thread/src/ipc.c **** 
1750:./rt_thread/src/ipc.c ****         return RT_EOK;
 1903              		.loc 2 1750 16
 1904 014c 0023     		movs	r3, #0
 1905 014e 04E0     		b	.L78
 1906              	.L86:
1751:./rt_thread/src/ipc.c ****     }
1752:./rt_thread/src/ipc.c **** 
1753:./rt_thread/src/ipc.c ****     /* enable interrupt */
1754:./rt_thread/src/ipc.c ****     rt_hw_interrupt_enable(temp);
 1907              		.loc 2 1754 5
 1908 0150 2346     		mov	r3, r4
 1909 0152 1846     		mov	r0, r3
 1910 0154 FFF7FEFF 		bl	rt_hw_interrupt_enable
1755:./rt_thread/src/ipc.c **** 
1756:./rt_thread/src/ipc.c ****     RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(mb->parent.parent)));
1757:./rt_thread/src/ipc.c **** 
1758:./rt_thread/src/ipc.c ****     return RT_EOK;
 1911              		.loc 2 1758 12
 1912 0158 0023     		movs	r3, #0
 1913              	.L78:
1759:./rt_thread/src/ipc.c **** }
 1914              		.loc 2 1759 1
 1915 015a 1846     		mov	r0, r3
 1916 015c 1C37     		adds	r7, r7, #28
 1917              	.LCFI111:
 1918              		.cfi_def_cfa_offset 12
 1919 015e BD46     		mov	sp, r7
 1920              	.LCFI112:
 1921              		.cfi_def_cfa_register 13
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 67


 1922              		@ sp needed
 1923 0160 90BD     		pop	{r4, r7, pc}
 1924              		.cfi_endproc
 1925              	.LFE33:
 1927              		.section	.text.rt_mb_control,"ax",%progbits
 1928              		.align	1
 1929              		.global	rt_mb_control
 1930              		.syntax unified
 1931              		.thumb
 1932              		.thumb_func
 1934              	rt_mb_control:
 1935              	.LFB34:
1760:./rt_thread/src/ipc.c **** 
1761:./rt_thread/src/ipc.c **** /**
1762:./rt_thread/src/ipc.c ****  * This function can get or set some extra attributions of a mailbox object.
1763:./rt_thread/src/ipc.c ****  *
1764:./rt_thread/src/ipc.c ****  * @param mb the mailbox object
1765:./rt_thread/src/ipc.c ****  * @param cmd the execution command
1766:./rt_thread/src/ipc.c ****  * @param arg the execution argument
1767:./rt_thread/src/ipc.c ****  *
1768:./rt_thread/src/ipc.c ****  * @return the error code
1769:./rt_thread/src/ipc.c ****  */
1770:./rt_thread/src/ipc.c **** rt_err_t rt_mb_control(rt_mailbox_t mb, int cmd, void *arg)
1771:./rt_thread/src/ipc.c **** {
 1936              		.loc 2 1771 1
 1937              		.cfi_startproc
 1938              		@ args = 0, pretend = 0, frame = 24
 1939              		@ frame_needed = 1, uses_anonymous_args = 0
 1940 0000 80B5     		push	{r7, lr}
 1941              	.LCFI113:
 1942              		.cfi_def_cfa_offset 8
 1943              		.cfi_offset 7, -8
 1944              		.cfi_offset 14, -4
 1945 0002 86B0     		sub	sp, sp, #24
 1946              	.LCFI114:
 1947              		.cfi_def_cfa_offset 32
 1948 0004 00AF     		add	r7, sp, #0
 1949              	.LCFI115:
 1950              		.cfi_def_cfa_register 7
 1951 0006 F860     		str	r0, [r7, #12]
 1952 0008 B960     		str	r1, [r7, #8]
 1953 000a 7A60     		str	r2, [r7, #4]
1772:./rt_thread/src/ipc.c ****     rt_ubase_t level;
1773:./rt_thread/src/ipc.c **** 
1774:./rt_thread/src/ipc.c ****     /* parameter check */
1775:./rt_thread/src/ipc.c ****     RT_ASSERT(mb != RT_NULL);
1776:./rt_thread/src/ipc.c ****     RT_ASSERT(rt_object_get_type(&mb->parent.parent) == RT_Object_Class_MailBox);
1777:./rt_thread/src/ipc.c **** 
1778:./rt_thread/src/ipc.c ****     if (cmd == RT_IPC_CMD_RESET)
 1954              		.loc 2 1778 8
 1955 000c BB68     		ldr	r3, [r7, #8]
 1956 000e 012B     		cmp	r3, #1
 1957 0010 1ED1     		bne	.L88
1779:./rt_thread/src/ipc.c ****     {
1780:./rt_thread/src/ipc.c ****         /* disable interrupt */
1781:./rt_thread/src/ipc.c ****         level = rt_hw_interrupt_disable();
 1958              		.loc 2 1781 17
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 68


 1959 0012 FFF7FEFF 		bl	rt_hw_interrupt_disable
 1960 0016 0346     		mov	r3, r0
 1961              		.loc 2 1781 15
 1962 0018 7B61     		str	r3, [r7, #20]
1782:./rt_thread/src/ipc.c **** 
1783:./rt_thread/src/ipc.c ****         /* resume all waiting thread */
1784:./rt_thread/src/ipc.c ****         rt_ipc_list_resume_all(&(mb->parent.suspend_thread));
 1963              		.loc 2 1784 9
 1964 001a FB68     		ldr	r3, [r7, #12]
 1965 001c 1433     		adds	r3, r3, #20
 1966 001e 1846     		mov	r0, r3
 1967 0020 FFF7FEFF 		bl	rt_ipc_list_resume_all
1785:./rt_thread/src/ipc.c ****         /* also resume all mailbox private suspended thread */
1786:./rt_thread/src/ipc.c ****         rt_ipc_list_resume_all(&(mb->suspend_sender_thread));
 1968              		.loc 2 1786 9
 1969 0024 FB68     		ldr	r3, [r7, #12]
 1970 0026 2833     		adds	r3, r3, #40
 1971 0028 1846     		mov	r0, r3
 1972 002a FFF7FEFF 		bl	rt_ipc_list_resume_all
1787:./rt_thread/src/ipc.c **** 
1788:./rt_thread/src/ipc.c ****         /* re-init mailbox */
1789:./rt_thread/src/ipc.c ****         mb->entry      = 0;
 1973              		.loc 2 1789 24
 1974 002e FB68     		ldr	r3, [r7, #12]
 1975 0030 0022     		movs	r2, #0
 1976 0032 5A84     		strh	r2, [r3, #34]	@ movhi
1790:./rt_thread/src/ipc.c ****         mb->in_offset  = 0;
 1977              		.loc 2 1790 24
 1978 0034 FB68     		ldr	r3, [r7, #12]
 1979 0036 0022     		movs	r2, #0
 1980 0038 9A84     		strh	r2, [r3, #36]	@ movhi
1791:./rt_thread/src/ipc.c ****         mb->out_offset = 0;
 1981              		.loc 2 1791 24
 1982 003a FB68     		ldr	r3, [r7, #12]
 1983 003c 0022     		movs	r2, #0
 1984 003e DA84     		strh	r2, [r3, #38]	@ movhi
1792:./rt_thread/src/ipc.c **** 
1793:./rt_thread/src/ipc.c ****         /* enable interrupt */
1794:./rt_thread/src/ipc.c ****         rt_hw_interrupt_enable(level);
 1985              		.loc 2 1794 9
 1986 0040 7B69     		ldr	r3, [r7, #20]
 1987 0042 1846     		mov	r0, r3
 1988 0044 FFF7FEFF 		bl	rt_hw_interrupt_enable
1795:./rt_thread/src/ipc.c **** 
1796:./rt_thread/src/ipc.c ****         rt_schedule();
 1989              		.loc 2 1796 9
 1990 0048 FFF7FEFF 		bl	rt_schedule
1797:./rt_thread/src/ipc.c **** 
1798:./rt_thread/src/ipc.c ****         return RT_EOK;
 1991              		.loc 2 1798 16
 1992 004c 0023     		movs	r3, #0
 1993 004e 01E0     		b	.L89
 1994              	.L88:
1799:./rt_thread/src/ipc.c ****     }
1800:./rt_thread/src/ipc.c **** 
1801:./rt_thread/src/ipc.c ****     return -RT_ERROR;
 1995              		.loc 2 1801 12
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 69


 1996 0050 4FF0FF33 		mov	r3, #-1
 1997              	.L89:
1802:./rt_thread/src/ipc.c **** }
 1998              		.loc 2 1802 1
 1999 0054 1846     		mov	r0, r3
 2000 0056 1837     		adds	r7, r7, #24
 2001              	.LCFI116:
 2002              		.cfi_def_cfa_offset 8
 2003 0058 BD46     		mov	sp, r7
 2004              	.LCFI117:
 2005              		.cfi_def_cfa_register 13
 2006              		@ sp needed
 2007 005a 80BD     		pop	{r7, pc}
 2008              		.cfi_endproc
 2009              	.LFE34:
 2011              		.text
 2012              	.Letext0:
 2013              		.file 3 "./rt_thread/include/rtdef.h"
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 70


DEFINED SYMBOLS
                            *ABS*:00000000 ipc.c
C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s:18     .text.rt_list_init:00000000 $t
C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s:23     .text.rt_list_init:00000000 rt_list_init
C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s:70     .text.rt_list_insert_before:00000000 $t
C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s:75     .text.rt_list_insert_before:00000000 rt_list_insert_before
C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s:132    .text.rt_list_isempty:00000000 $t
C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s:137    .text.rt_list_isempty:00000000 rt_list_isempty
C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s:183    .text.rt_ipc_object_init:00000000 $t
C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s:188    .text.rt_ipc_object_init:00000000 rt_ipc_object_init
C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s:228    .text.rt_ipc_list_suspend:00000000 $t
C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s:233    .text.rt_ipc_list_suspend:00000000 rt_ipc_list_suspend
C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s:350    .text.rt_ipc_list_resume:00000000 $t
C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s:355    .text.rt_ipc_list_resume:00000000 rt_ipc_list_resume
C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s:398    .text.rt_ipc_list_resume_all:00000000 $t
C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s:403    .text.rt_ipc_list_resume_all:00000000 rt_ipc_list_resume_all
C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s:471    .text.rt_sem_init:00000000 $t
C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s:477    .text.rt_sem_init:00000000 rt_sem_init
C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s:534    .text.rt_sem_detach:00000000 $t
C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s:540    .text.rt_sem_detach:00000000 rt_sem_detach
C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s:583    .text.rt_sem_create:00000000 $t
C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s:589    .text.rt_sem_create:00000000 rt_sem_create
C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s:653    .text.rt_sem_delete:00000000 $t
C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s:659    .text.rt_sem_delete:00000000 rt_sem_delete
C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s:702    .text.rt_sem_take:00000000 $t
C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s:708    .text.rt_sem_take:00000000 rt_sem_take
C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s:828    .text.rt_sem_trytake:00000000 $t
C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s:834    .text.rt_sem_trytake:00000000 rt_sem_trytake
C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s:871    .text.rt_sem_release:00000000 $t
C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s:877    .text.rt_sem_release:00000000 rt_sem_release
C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s:971    .text.rt_sem_control:00000000 $t
C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s:977    .text.rt_sem_control:00000000 rt_sem_control
C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s:1049   .text.rt_mb_init:00000000 $t
C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s:1055   .text.rt_mb_init:00000000 rt_mb_init
C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s:1132   .text.rt_mb_detach:00000000 $t
C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s:1138   .text.rt_mb_detach:00000000 rt_mb_detach
C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s:1186   .text.rt_mb_create:00000000 $t
C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s:1192   .text.rt_mb_create:00000000 rt_mb_create
C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s:1297   .text.rt_mb_delete:00000000 $t
C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s:1303   .text.rt_mb_delete:00000000 rt_mb_delete
C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s:1356   .text.rt_mb_send_wait:00000000 $t
C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s:1362   .text.rt_mb_send_wait:00000000 rt_mb_send_wait
C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s:1625   .text.rt_mb_send:00000000 $t
C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s:1631   .text.rt_mb_send:00000000 rt_mb_send
C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s:1670   .text.rt_mb_recv:00000000 $t
C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s:1676   .text.rt_mb_recv:00000000 rt_mb_recv
C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s:1928   .text.rt_mb_control:00000000 $t
C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s:1934   .text.rt_mb_control:00000000 rt_mb_control

UNDEFINED SYMBOLS
rt_thread_suspend
rt_thread_resume
rt_hw_interrupt_disable
rt_hw_interrupt_enable
rt_object_init
rt_object_detach
rt_object_allocate
ARM GAS  C:\Users\hao\AppData\Local\Temp\ccQNLUfS.s 			page 71


rt_object_delete
rt_thread_self
rt_timer_control
rt_timer_start
rt_schedule
rt_malloc
rt_free
rt_tick_get
